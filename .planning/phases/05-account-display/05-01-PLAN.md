---
phase: 05-account-display
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/orchestrator_3_stream/backend/schemas/account_schemas.py
  - apps/orchestrator_3_stream/backend/modules/account_service.py
  - apps/orchestrator_3_stream/backend/routers/credentials.py
autonomous: true

must_haves:
  truths:
    - "GET /api/credentials/{id}/account-data returns account metrics"
    - "Endpoint returns account_type, balance, equity, buying_power, pattern_day_trader, daytrade_count"
    - "Endpoint uses decrypt-on-demand pattern for credentials"
    - "Endpoint uses credential_type from database to determine paper vs live routing"
  artifacts:
    - path: "apps/orchestrator_3_stream/backend/schemas/account_schemas.py"
      provides: "AccountDataResponse Pydantic model"
      contains: "class AccountDataResponse"
    - path: "apps/orchestrator_3_stream/backend/modules/account_service.py"
      provides: "fetch_alpaca_account_data function"
      contains: "async def fetch_alpaca_account_data"
    - path: "apps/orchestrator_3_stream/backend/routers/credentials.py"
      provides: "Account data endpoint"
      contains: "account-data"
  key_links:
    - from: "routers/credentials.py"
      to: "modules/account_service.py"
      via: "fetch_alpaca_account_data import"
      pattern: "from modules.account_service import"
    - from: "routers/credentials.py"
      to: "modules/credential_service.py"
      via: "get_decrypted_alpaca_credential for secure credential access"
      pattern: "get_decrypted_alpaca_credential"
---

<objective>
Create backend endpoint to fetch real-time Alpaca account data (type, balance, equity, buying power).

Purpose: Frontend needs an API to retrieve account metrics for display. This endpoint fetches live data from Alpaca using stored credentials with the established decrypt-on-demand pattern.

Output: New endpoint GET /api/credentials/{credential_id}/account-data returning AccountDataResponse with account_type, balance, equity, buying_power, currency, trading_blocked fields.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-account-display/05-RESEARCH.md
@apps/orchestrator_3_stream/backend/modules/credential_service.py
@apps/orchestrator_3_stream/backend/routers/credentials.py
@apps/orchestrator_3_stream/backend/schemas/credential_schemas.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add AccountDataResponse schema</name>
  <files>apps/orchestrator_3_stream/backend/schemas/account_schemas.py</files>
  <action>
Add AccountDataResponse Pydantic model to the existing account_schemas.py file:

```python
class AccountDataResponse(BaseModel):
    """Real-time account data from Alpaca API."""

    account_type: str = Field(
        ...,
        description="Account type: 'paper' or 'live'"
    )
    balance: str = Field(
        ...,
        description="Cash balance (currency units as string)"
    )
    equity: str = Field(
        ...,
        description="Total equity: cash + positions"
    )
    buying_power: str = Field(
        ...,
        description="Available buying power"
    )
    currency: str = Field(
        default="USD",
        description="Account currency"
    )
    trading_blocked: bool = Field(
        default=False,
        description="Whether trading is blocked"
    )
    account_blocked: bool = Field(
        default=False,
        description="Whether account activity is prohibited"
    )
    pattern_day_trader: bool = Field(
        default=False,
        description="Whether flagged as pattern day trader"
    )
    daytrade_count: int = Field(
        default=0,
        description="Day trades in last 5 trading days"
    )
    last_updated: str = Field(
        ...,
        description="Timestamp of last fetch (ISO 8601)"
    )
```

Use string types for balance/equity/buying_power to preserve precision (Alpaca returns decimal strings).
  </action>
  <verify>
Run: `cd /Users/muzz/Desktop/tac/TOD/apps/orchestrator_3_stream/backend && uv run python -c "from schemas.account_schemas import AccountDataResponse; print('AccountDataResponse imported successfully')"`
  </verify>
  <done>AccountDataResponse schema exists and imports without error</done>
</task>

<task type="auto">
  <name>Task 2: Create account service with fetch_alpaca_account_data</name>
  <files>apps/orchestrator_3_stream/backend/modules/account_service.py</files>
  <action>
Create new file modules/account_service.py with function to fetch Alpaca account data:

```python
#!/usr/bin/env python3
"""
Account Service

Fetches real-time account data from Alpaca API using decrypted credentials.
"""

from typing import Dict, Any
from alpaca.trading.client import TradingClient
from modules.logger import OrchestratorLogger

logger = OrchestratorLogger("account_service")

async def fetch_alpaca_account_data(
    api_key: str,
    secret_key: str,
    account_type: str,  # "paper" or "live" - determines API endpoint
) -> Dict[str, Any]:
    """
    Fetch real-time account data from Alpaca API.

    Args:
        api_key: Alpaca API key (plaintext, already decrypted)
        secret_key: Alpaca secret key (plaintext, already decrypted)
        account_type: "paper" or "live" to select correct endpoint

    Returns:
        Dict with keys: account_type, cash, equity, buying_power, currency, trading_blocked

    Raises:
        Exception: If API call fails
    """
    try:
        # TradingClient uses paper=True for paper-api.alpaca.markets
        client = TradingClient(
            api_key=api_key,
            secret_key=secret_key,
            paper=account_type == "paper"
        )

        # get_account() is synchronous in alpaca-py
        account = client.get_account()

        logger.info(f"Fetched account data for {account_type} account")

        return {
            "account_type": account_type,
            "cash": str(account.cash),
            "equity": str(account.equity),
            "buying_power": str(account.buying_power),
            "currency": getattr(account, 'currency', None) or "USD",
            "trading_blocked": getattr(account, 'trading_blocked', False) or False,
            "account_blocked": getattr(account, 'account_blocked', False) or False,
            "pattern_day_trader": getattr(account, 'pattern_day_trader', False) or False,
            "daytrade_count": getattr(account, 'daytrade_count', 0) or 0,
        }
    except Exception as e:
        logger.error(f"Failed to fetch account data: {e}")
        raise

__all__ = ["fetch_alpaca_account_data"]
```

Note: alpaca-py TradingClient.get_account() is synchronous, but we wrap in async function for consistency with codebase patterns.
  </action>
  <verify>
Run: `cd /Users/muzz/Desktop/tac/TOD/apps/orchestrator_3_stream/backend && uv run python -c "from modules.account_service import fetch_alpaca_account_data; print('account_service imported successfully')"`
  </verify>
  <done>account_service.py exists with fetch_alpaca_account_data function that imports successfully</done>
</task>

<task type="auto">
  <name>Task 3: Add account-data endpoint to credentials router</name>
  <files>apps/orchestrator_3_stream/backend/routers/credentials.py</files>
  <action>
Add new endpoint to credentials.py router:

1. Add import at top:
```python
from datetime import datetime
from modules.account_service import fetch_alpaca_account_data
from schemas.account_schemas import AccountDataResponse
```

2. Add endpoint after validate_credential_endpoint:
```python
@router.get("/{credential_id}/account-data", response_model=AccountDataResponse)
async def get_credential_account_data(
    credential_id: str,
    user: AuthUser = Depends(get_current_user),
):
    """
    Fetch real-time account data from Alpaca using stored credential.

    Decrypts credential, calls Alpaca /v2/account API, returns formatted response.

    Args:
        credential_id: UUID of credential to use for API call
        user: Current authenticated user

    Returns:
        AccountDataResponse with account_type, balance, equity, buying_power

    Raises:
        HTTPException: 403 if unauthorized, 400 if inactive, 500 if API fails
    """
    try:
        logger.info(f"Fetching account data for credential {credential_id}, user {user.id}")

        async with get_connection_with_rls(user.id) as conn:
            # First, get credential to determine account_type
            # We need to know if it's paper or live before calling Alpaca
            result = await conn.fetch(
                """
                SELECT credential_type FROM user_credentials WHERE id = $1
                """,
                UUID(credential_id),
            )

            if not result:
                raise HTTPException(
                    status_code=status.HTTP_404_NOT_FOUND,
                    detail=f"Credential {credential_id} not found"
                )

            credential_type = result[0]["credential_type"]

            # Decrypt credential and fetch account data
            try:
                async with get_decrypted_alpaca_credential(conn, credential_id, user.id) as (
                    api_key,
                    secret_key,
                ):
                    # Use credential_type from database to determine paper vs live
                    # credential_type is stored during credential validation (Phase 3)
                    account_type = credential_type.lower()  # "paper" or "live"

                    # Fetch account data from Alpaca
                    account_data = await fetch_alpaca_account_data(
                        api_key, secret_key, account_type
                    )

                    logger.info(f"Account data fetched for credential {credential_id}")

                    return AccountDataResponse(
                        account_type=account_data["account_type"],
                        balance=account_data["cash"],
                        equity=account_data["equity"],
                        buying_power=account_data["buying_power"],
                        currency=account_data["currency"],
                        trading_blocked=account_data["trading_blocked"],
                        account_blocked=account_data["account_blocked"],
                        pattern_day_trader=account_data["pattern_day_trader"],
                        daytrade_count=account_data["daytrade_count"],
                        last_updated=datetime.utcnow().isoformat() + "Z",
                    )

            except ValueError as e:
                logger.warning(f"Account data fetch failed: {e}")
                if "inactive" in str(e):
                    raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(e))
                else:
                    raise HTTPException(status_code=status.HTTP_403_FORBIDDEN, detail=str(e))

    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Failed to fetch account data: {e}")
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail=str(e))
```

3. Add to __all__ if it exists, or ensure router export is maintained.
  </action>
  <verify>
Run: `cd /Users/muzz/Desktop/tac/TOD/apps/orchestrator_3_stream/backend && uv run python -c "from routers.credentials import router; routes = [r.path for r in router.routes]; print('Routes:', routes); assert '/{credential_id}/account-data' in routes, 'account-data endpoint missing'"`
  </verify>
  <done>GET /api/credentials/{credential_id}/account-data endpoint exists and is registered in router</done>
</task>

</tasks>

<verification>
1. All imports work: `uv run python -c "from schemas.account_schemas import AccountDataResponse; from modules.account_service import fetch_alpaca_account_data; from routers.credentials import router; print('All imports successful')"`

2. Backend starts without errors: `cd /Users/muzz/Desktop/tac/TOD/apps/orchestrator_3_stream && ./start_be.sh` (check logs for startup)

3. API docs show endpoint: Visit http://localhost:8002/docs and verify `/api/credentials/{credential_id}/account-data` appears
</verification>

<success_criteria>
- AccountDataResponse schema defined with all required fields
- fetch_alpaca_account_data function in account_service.py
- GET /api/credentials/{credential_id}/account-data endpoint registered
- Endpoint uses decrypt-on-demand pattern (get_decrypted_alpaca_credential)
- All code compiles and backend starts without errors
</success_criteria>

<output>
After completion, create `.planning/phases/05-account-display/05-01-SUMMARY.md`
</output>
