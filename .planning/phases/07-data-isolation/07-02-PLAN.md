---
phase: 07-data-isolation
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/orchestrator_3_stream/backend/tests/test_data_isolation.py
autonomous: true

must_haves:
  truths:
    - "Integration test verifies User A cannot see User B's credentials via RLS"
    - "Integration test verifies positions endpoint returns 403 for wrong user's credential"
    - "Integration test verifies orders endpoint returns 403 for wrong user's credential"
  artifacts:
    - path: "apps/orchestrator_3_stream/backend/tests/test_data_isolation.py"
      provides: "RLS isolation integration tests"
      min_lines: 80
  key_links:
    - from: "tests/test_data_isolation.py"
      to: "get_connection_with_rls"
      via: "tests verify RLS policies enforce isolation"
      pattern: "get_connection_with_rls"
---

<objective>
Create integration tests that verify PostgreSQL RLS policies correctly isolate user data.

Purpose: Ensure User A cannot see User B's credentials, positions, or orders through database queries. These tests use real database connections with RLS context to verify isolation works at the database level.

Output: New test file with comprehensive RLS isolation tests that can be run as part of CI.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-data-isolation/07-RESEARCH.md

# Existing test patterns to follow
@apps/orchestrator_3_stream/backend/tests/test_credential_endpoints.py
@apps/orchestrator_3_stream/backend/tests/test_user_credentials.py

# RLS implementation
@apps/orchestrator_db/migrations/15_user_credentials_rls.sql
@apps/orchestrator_3_stream/backend/modules/database.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create RLS isolation integration tests</name>
  <files>apps/orchestrator_3_stream/backend/tests/test_data_isolation.py</files>
  <action>
Create a new test file that verifies RLS policies enforce data isolation.

Follow the existing test patterns from test_credential_endpoints.py and test_user_credentials.py:
- Use real database connections (no mocking per CLAUDE.md)
- Ephemeral test data (create -> test -> cleanup)
- Use pytest-asyncio for async tests

Test scenarios to implement:

1. **test_user_a_cannot_see_user_b_credentials**:
   - Create credential for User A using get_connection_with_rls(user_a_id)
   - Query credentials with get_connection_with_rls(user_b_id)
   - Assert: User B's query returns empty result (RLS filtered)

2. **test_user_can_see_own_credentials**:
   - Create credential for User A
   - Query with User A's RLS context
   - Assert: Credential is returned

3. **test_rls_context_required_for_queries**:
   - Query without setting RLS context (use raw connection)
   - Assert: Either returns empty or RLS policy enforces null current_user_id()

4. **test_credential_isolation_with_multiple_users**:
   - Create credentials for User A and User B
   - Query with User A's context
   - Assert: Only User A's credentials returned
   - Query with User B's context
   - Assert: Only User B's credentials returned

Use temporary UUIDs for test user IDs (not real users). Clean up all test data in teardown.

Important: Use the existing `set_rls_context` and `get_connection_with_rls` functions from database.py.
  </action>
  <verify>
Run the tests:
```bash
cd apps/orchestrator_3_stream/backend && uv run pytest tests/test_data_isolation.py -v
```
All tests should pass.
  </verify>
  <done>
test_data_isolation.py exists with at least 4 test cases verifying RLS credential isolation, all tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add endpoint isolation tests</name>
  <files>apps/orchestrator_3_stream/backend/tests/test_data_isolation.py</files>
  <action>
Add API endpoint tests to the same file that verify the positions and orders endpoints enforce isolation.

These tests verify the full stack (HTTP -> FastAPI -> RLS -> Database):

1. **test_positions_endpoint_rejects_wrong_user_credential**:
   - Setup: Create credential for User A
   - Action: Make GET /api/positions request with User B's auth + User A's credential_id
   - Assert: Returns error status (credential not found/access denied)
   - Note: Use httpx AsyncClient to make requests to the running app

2. **test_orders_endpoint_rejects_wrong_user_credential**:
   - Same pattern as positions test
   - GET /api/orders with wrong user's credential_id

3. **test_positions_endpoint_accepts_own_credential**:
   - Setup: Create credential for User A
   - Action: Make request with User A's auth + User A's credential_id
   - Assert: Returns success (may be empty positions, but not error)

Use pytest fixtures for app client setup. Follow patterns from test_credential_endpoints.py.

Since these are integration tests that need real Alpaca credentials to work fully, mark them appropriately:
- Mark database-only tests as regular tests
- Mark Alpaca-dependent tests with `@pytest.mark.integration` if they need real API keys
  </action>
  <verify>
Run all isolation tests:
```bash
cd apps/orchestrator_3_stream/backend && uv run pytest tests/test_data_isolation.py -v
```
  </verify>
  <done>
Endpoint isolation tests exist and verify that positions/orders endpoints reject credentials not owned by the requesting user.
  </done>
</task>

</tasks>

<verification>
1. Test file exists: `ls apps/orchestrator_3_stream/backend/tests/test_data_isolation.py`
2. All tests pass: `cd apps/orchestrator_3_stream/backend && uv run pytest tests/test_data_isolation.py -v`
3. Tests use real database (no mocking)
4. Tests clean up ephemeral data
</verification>

<success_criteria>
- [ ] test_data_isolation.py exists with at least 6 test cases
- [ ] RLS credential isolation tests pass
- [ ] Endpoint isolation tests verify access denied for wrong user
- [ ] Tests follow ephemeral data pattern (setup -> test -> cleanup)
- [ ] All tests pass with `uv run pytest`
</success_criteria>

<output>
After completion, create `.planning/phases/07-data-isolation/07-02-SUMMARY.md`
</output>
