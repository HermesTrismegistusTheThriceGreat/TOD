---
phase: 02-database-schema
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/orchestrator_db/migrations/14_user_accounts.sql
  - apps/orchestrator_db/models.py
autonomous: true

must_haves:
  truths:
    - "user_accounts table exists in database with correct columns"
    - "user_credentials table exists in database with correct columns"
    - "Foreign key from user_accounts.user_id references user.id"
    - "Foreign key from user_credentials.user_account_id references user_accounts.id"
    - "CASCADE DELETE removes credentials when account deleted"
    - "Indexes exist on user_id columns for RLS performance"
  artifacts:
    - path: "apps/orchestrator_db/migrations/14_user_accounts.sql"
      provides: "Database schema for user accounts and credentials tables"
      contains: "CREATE TABLE user_accounts"
    - path: "apps/orchestrator_db/models.py"
      provides: "Pydantic models for UserAccount and UserCredential"
      contains: "class UserAccount"
  key_links:
    - from: "user_accounts.user_id"
      to: "user.id"
      via: "FOREIGN KEY REFERENCES"
      pattern: "REFERENCES.*user.*id"
    - from: "user_credentials.user_account_id"
      to: "user_accounts.id"
      via: "FOREIGN KEY ON DELETE CASCADE"
      pattern: "ON DELETE CASCADE"
---

<objective>
Create database migration for user_accounts and user_credentials tables with proper foreign keys, indexes, and Pydantic models.

Purpose: Establish the database schema foundation for multi-user credential storage with proper referential integrity and performance indexes.
Output: SQL migration file creating tables with indexes, and Pydantic models for application use.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-database-schema/02-RESEARCH.md
@.planning/phases/01-security-foundation/01-01-SUMMARY.md
@apps/orchestrator_db/models.py
@apps/orchestrator_db/migrations/13_better_auth_tables.sql
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create user_accounts and user_credentials migration</name>
  <files>apps/orchestrator_db/migrations/14_user_accounts.sql</files>
  <action>
Create SQL migration file with:

**user_accounts table:**
- id: UUID PRIMARY KEY DEFAULT gen_random_uuid()
- user_id: TEXT NOT NULL UNIQUE - references "user"(id) from Better Auth with ON DELETE CASCADE
- account_name: VARCHAR(255) NOT NULL - display name (e.g., "Trading Account 1", "Paper Account")
- is_active: BOOLEAN DEFAULT TRUE
- created_at: TIMESTAMPTZ DEFAULT NOW()
- updated_at: TIMESTAMPTZ DEFAULT NOW()

**user_credentials table:**
- id: UUID PRIMARY KEY DEFAULT gen_random_uuid()
- user_account_id: UUID NOT NULL - references user_accounts(id) with ON DELETE CASCADE
- user_id: TEXT NOT NULL - DENORMALIZED for RLS (copy from user_accounts, avoid joins in policy)
- credential_type: VARCHAR(50) NOT NULL - "alpaca", "polygon", etc.
- api_key: TEXT NOT NULL - will be encrypted by TypeDecorator (Phase 2 Plan 3)
- secret_key: TEXT NOT NULL - will be encrypted by TypeDecorator (Phase 2 Plan 3)
- is_active: BOOLEAN DEFAULT TRUE
- expires_at: TIMESTAMPTZ - optional credential expiration
- created_at: TIMESTAMPTZ DEFAULT NOW()
- updated_at: TIMESTAMPTZ DEFAULT NOW()

**Indexes (CRITICAL for RLS performance):**
- idx_user_accounts_user_id ON user_accounts(user_id)
- idx_user_credentials_user_id ON user_credentials(user_id)
- idx_user_credentials_account_id ON user_credentials(user_account_id)

**Unique constraint:**
- idx_user_credentials_unique ON user_credentials(user_account_id, credential_type)

Include:
- Header comment block explaining purpose and dependencies
- COMMENT ON TABLE/COLUMN statements for documentation
- IF NOT EXISTS for idempotent migrations
  </action>
  <verify>
Run: `psql $DATABASE_URL -f apps/orchestrator_db/migrations/14_user_accounts.sql`
Tables exist: `psql $DATABASE_URL -c "\d user_accounts"` and `\d user_credentials`
Indexes exist: `psql $DATABASE_URL -c "\di idx_user_*"`
  </verify>
  <done>
Migration file creates both tables with all columns, foreign keys, indexes, and comments.
Tables can be created successfully on a fresh database or idempotently on existing database.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add Pydantic models for UserAccount and UserCredential</name>
  <files>apps/orchestrator_db/models.py</files>
  <action>
Add two new Pydantic models to apps/orchestrator_db/models.py following the existing patterns:

**UserAccount model:**
```python
class UserAccount(BaseModel):
    """
    User's trading account (linked to Better Auth user).

    Maps to: user_accounts table
    """
    id: UUID
    user_id: str  # TEXT in DB, maps to user.id from Better Auth
    account_name: str
    is_active: bool = True
    created_at: datetime
    updated_at: datetime

    @field_validator('id', mode='before')
    @classmethod
    def convert_uuid(cls, v):
        """Convert asyncpg UUID to Python UUID"""
        if isinstance(v, UUID):
            return v
        return UUID(str(v))

    class Config:
        from_attributes = True
        json_encoders = {
            UUID: str,
            datetime: lambda v: v.isoformat()
        }
```

**UserCredential model:**
```python
class UserCredential(BaseModel):
    """
    Encrypted API credentials for a user account.

    Maps to: user_credentials table
    Note: api_key and secret_key are stored encrypted in DB.
    Decryption happens via SQLAlchemy TypeDecorator (see user_models.py).
    """
    id: UUID
    user_account_id: UUID
    user_id: str  # Denormalized for RLS
    credential_type: str  # "alpaca", "polygon", etc.
    api_key: str  # Note: This is the decrypted value after ORM retrieval
    secret_key: str  # Note: This is the decrypted value after ORM retrieval
    is_active: bool = True
    expires_at: Optional[datetime] = None
    created_at: datetime
    updated_at: datetime

    @field_validator('id', 'user_account_id', mode='before')
    @classmethod
    def convert_uuid(cls, v):
        """Convert asyncpg UUID to Python UUID"""
        if isinstance(v, UUID):
            return v
        return UUID(str(v))

    class Config:
        from_attributes = True
        json_encoders = {
            UUID: str,
            datetime: lambda v: v.isoformat()
        }
```

Add to __all__ list: "UserAccount", "UserCredential"

Pattern notes:
- Follow existing model patterns (field_validator for UUID conversion)
- Use str for user_id (TEXT in Better Auth)
- Include Optional[datetime] for expires_at
- Add docstrings referencing the table mapping
  </action>
  <verify>
Run: `python -c "from apps.orchestrator_db.models import UserAccount, UserCredential; print('Models imported successfully')"`
Type check: Models have correct fields and validators
  </verify>
  <done>
UserAccount and UserCredential Pydantic models exist in models.py with proper UUID conversion, type hints, and Config.
Models are exported in __all__ list.
  </done>
</task>

</tasks>

<verification>
1. Migration file exists at apps/orchestrator_db/migrations/14_user_accounts.sql
2. Migration creates user_accounts table with correct columns
3. Migration creates user_credentials table with correct columns
4. Foreign key user_accounts.user_id -> user.id exists with CASCADE DELETE
5. Foreign key user_credentials.user_account_id -> user_accounts.id exists with CASCADE DELETE
6. All 4 indexes are created (idx_user_accounts_user_id, idx_user_credentials_user_id, idx_user_credentials_account_id, idx_user_credentials_unique)
7. Pydantic UserAccount and UserCredential models importable from models.py
8. Models follow existing patterns (field_validator, Config, __all__)
</verification>

<success_criteria>
- SQL migration file creates both tables with all columns, constraints, and indexes
- Migration is idempotent (can run multiple times without error)
- Foreign keys enforce referential integrity between user -> user_accounts -> user_credentials
- CASCADE DELETE ensures credential cleanup when account/user deleted
- Indexes on user_id columns prepared for RLS policy performance (Plan 02)
- Pydantic models mirror database schema for application use
</success_criteria>

<output>
After completion, create `.planning/phases/02-database-schema/02-01-SUMMARY.md`
</output>
