---
phase: 02-database-schema
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - apps/orchestrator_db/migrations/15_user_credentials_rls.sql
autonomous: true

must_haves:
  truths:
    - "RLS is enabled on user_accounts table"
    - "RLS is enabled on user_credentials table"
    - "User can only SELECT their own accounts (verified via policy)"
    - "User can only SELECT their own credentials (verified via policy)"
    - "User can only INSERT/UPDATE/DELETE their own data"
    - "current_user_id() function returns the authenticated user ID from session context"
  artifacts:
    - path: "apps/orchestrator_db/migrations/15_user_credentials_rls.sql"
      provides: "RLS policies for user data isolation"
      contains: "ENABLE ROW LEVEL SECURITY"
  key_links:
    - from: "RLS policy"
      to: "current_user_id()"
      via: "USING clause"
      pattern: "USING.*current_user_id"
    - from: "current_user_id()"
      to: "current_setting"
      via: "Session variable"
      pattern: "current_setting.*app.current_user_id"
---

<objective>
Implement PostgreSQL Row-Level Security policies on user_accounts and user_credentials tables to enforce user data isolation at the database layer.

Purpose: Prevent users from accessing each other's data via database-enforced policies, providing defense-in-depth security beyond application-level checks.
Output: SQL migration file with RLS policies and a helper function for session-based user identification.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-database-schema/02-RESEARCH.md
@.planning/phases/02-database-schema/02-01-SUMMARY.md
@apps/orchestrator_db/migrations/14_user_accounts.sql
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create RLS policies migration</name>
  <files>apps/orchestrator_db/migrations/15_user_credentials_rls.sql</files>
  <action>
Create SQL migration file implementing Row-Level Security for user isolation.

**current_user_id() function:**
Create a helper function that retrieves the current user ID from PostgreSQL session variables.
The FastAPI backend will set this variable before each query using:
`SET LOCAL app.current_user_id = '{user_id}';`

```sql
-- Function to get current user from session context
-- Returns NULL if not set (important for RLS safety - NULL won't match any user_id)
CREATE OR REPLACE FUNCTION current_user_id() RETURNS TEXT AS $$
BEGIN
    RETURN NULLIF(current_setting('app.current_user_id', TRUE), '');
EXCEPTION
    WHEN OTHERS THEN
        RETURN NULL;
END;
$$ LANGUAGE plpgsql STABLE;
```

Note: STABLE marking allows query planner to cache result per statement.

**RLS on user_accounts:**
```sql
-- Enable RLS
ALTER TABLE user_accounts ENABLE ROW LEVEL SECURITY;

-- Force RLS even for table owner (critical for testing)
ALTER TABLE user_accounts FORCE ROW LEVEL SECURITY;

-- SELECT: Users see only their own accounts
CREATE POLICY user_accounts_select ON user_accounts
    FOR SELECT
    USING (user_id = current_user_id());

-- INSERT: Users can only create accounts for themselves
CREATE POLICY user_accounts_insert ON user_accounts
    FOR INSERT
    WITH CHECK (user_id = current_user_id());

-- UPDATE: Users can only update their own accounts
CREATE POLICY user_accounts_update ON user_accounts
    FOR UPDATE
    USING (user_id = current_user_id())
    WITH CHECK (user_id = current_user_id());

-- DELETE: Users can only delete their own accounts
CREATE POLICY user_accounts_delete ON user_accounts
    FOR DELETE
    USING (user_id = current_user_id());
```

**RLS on user_credentials:**
```sql
-- Enable RLS
ALTER TABLE user_credentials ENABLE ROW LEVEL SECURITY;

-- Force RLS even for table owner (critical for testing)
ALTER TABLE user_credentials FORCE ROW LEVEL SECURITY;

-- SELECT: Users see only their own credentials (via denormalized user_id)
CREATE POLICY user_credentials_select ON user_credentials
    FOR SELECT
    USING (user_id = current_user_id());

-- INSERT: Users can only create credentials for themselves
CREATE POLICY user_credentials_insert ON user_credentials
    FOR INSERT
    WITH CHECK (user_id = current_user_id());

-- UPDATE: Users can only update their own credentials
CREATE POLICY user_credentials_update ON user_credentials
    FOR UPDATE
    USING (user_id = current_user_id())
    WITH CHECK (user_id = current_user_id());

-- DELETE: Users can only delete their own credentials
CREATE POLICY user_credentials_delete ON user_credentials
    FOR DELETE
    USING (user_id = current_user_id());
```

Include:
- Header comment block explaining RLS purpose and usage pattern
- Comments explaining FORCE ROW LEVEL SECURITY importance
- Comments documenting how FastAPI should set session variable
- DROP POLICY IF EXISTS before CREATE for idempotency
  </action>
  <verify>
Run migration: `psql $DATABASE_URL -f apps/orchestrator_db/migrations/15_user_credentials_rls.sql`
Check RLS enabled: `psql $DATABASE_URL -c "SELECT relname, relrowsecurity, relforcerowsecurity FROM pg_class WHERE relname IN ('user_accounts', 'user_credentials');"`
Check policies: `psql $DATABASE_URL -c "SELECT * FROM pg_policies WHERE tablename IN ('user_accounts', 'user_credentials');"`
  </verify>
  <done>
RLS policies exist for both tables with SELECT/INSERT/UPDATE/DELETE operations.
current_user_id() function created and marked STABLE.
FORCE ROW LEVEL SECURITY enabled on both tables.
  </done>
</task>

<task type="auto">
  <name>Task 2: Document RLS usage in migration comments</name>
  <files>apps/orchestrator_db/migrations/15_user_credentials_rls.sql</files>
  <action>
Add comprehensive documentation block at the top of the migration file explaining:

1. **Purpose**: Database-enforced user isolation (defense in depth)

2. **How it works**:
   - FastAPI middleware sets `app.current_user_id` session variable before queries
   - RLS policies check this variable to filter rows
   - Queries automatically scoped to authenticated user

3. **FastAPI integration pattern**:
```python
# Example FastAPI middleware pattern:
async def set_user_context(conn, user_id: str):
    await conn.execute(f"SET LOCAL app.current_user_id = '{user_id}';")

# In database operations:
async with db.acquire() as conn:
    await set_user_context(conn, current_user.id)
    # All subsequent queries on this connection are RLS-filtered
    result = await conn.fetch("SELECT * FROM user_credentials")
```

4. **Testing considerations**:
   - FORCE ROW LEVEL SECURITY ensures policies apply even to table owner
   - Test with actual user IDs, not superuser accounts
   - Verify isolation: user_1 cannot see user_2's data

5. **Performance notes**:
   - Indexes on user_id columns (created in Plan 01) are critical
   - current_user_id() marked STABLE for query planner caching
   - Denormalized user_id on credentials avoids joins in policy
  </action>
  <verify>
Migration file contains comprehensive documentation block at top.
Documentation includes FastAPI integration example.
  </verify>
  <done>
Migration file includes detailed documentation explaining RLS purpose, usage, and integration pattern.
Developers reading the migration understand how to use RLS with FastAPI.
  </done>
</task>

</tasks>

<verification>
1. Migration file exists at apps/orchestrator_db/migrations/15_user_credentials_rls.sql
2. current_user_id() function exists and returns session variable or NULL
3. RLS enabled on user_accounts (relrowsecurity = true in pg_class)
4. RLS enabled on user_credentials (relrowsecurity = true in pg_class)
5. FORCE ROW LEVEL SECURITY enabled on both tables (relforcerowsecurity = true)
6. 4 policies exist for user_accounts (select, insert, update, delete)
7. 4 policies exist for user_credentials (select, insert, update, delete)
8. All policies use current_user_id() in USING/WITH CHECK clauses
9. Documentation block explains FastAPI integration pattern
</verification>

<success_criteria>
- RLS prevents any query without proper user context from returning rows
- Setting `app.current_user_id` session variable scopes all queries to that user
- User A cannot see User B's accounts or credentials (database-enforced)
- Policies cover all CRUD operations (SELECT, INSERT, UPDATE, DELETE)
- Documentation enables FastAPI integration in Phase 3
</success_criteria>

<output>
After completion, create `.planning/phases/02-database-schema/02-02-SUMMARY.md`
</output>
