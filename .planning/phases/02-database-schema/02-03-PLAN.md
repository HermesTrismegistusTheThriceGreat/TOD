---
phase: 02-database-schema
plan: 03
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - apps/orchestrator_3_stream/backend/modules/user_models.py
  - apps/orchestrator_3_stream/backend/tests/test_user_credentials.py
autonomous: true

must_haves:
  truths:
    - "EncryptedString TypeDecorator encrypts on INSERT/UPDATE"
    - "EncryptedString TypeDecorator decrypts on SELECT"
    - "SQLAlchemy UserCredentialORM model uses EncryptedString for api_key and secret_key"
    - "Encryption round-trip test passes for Alpaca key formats (PK..., sp...)"
    - "Tests verify credentials stored encrypted in database"
  artifacts:
    - path: "apps/orchestrator_3_stream/backend/modules/user_models.py"
      provides: "SQLAlchemy ORM models with encrypted columns"
      contains: "class EncryptedString"
    - path: "apps/orchestrator_3_stream/backend/tests/test_user_credentials.py"
      provides: "Tests for encrypted credential storage"
      contains: "test_credential_encryption_round_trip"
  key_links:
    - from: "EncryptedString"
      to: "encryption_service.py"
      via: "get_encryption_service()"
      pattern: "get_encryption_service"
    - from: "UserCredentialORM.api_key"
      to: "EncryptedString"
      via: "Column type"
      pattern: "Column.*EncryptedString"
---

<objective>
Create SQLAlchemy ORM models with transparent encryption via TypeDecorator and comprehensive tests for credential storage.

Purpose: Enable transparent encryption/decryption of API credentials during database operations, integrating with the encryption service from Phase 1.
Output: SQLAlchemy models with EncryptedString columns and tests verifying encryption behavior.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-database-schema/02-RESEARCH.md
@.planning/phases/02-database-schema/02-01-SUMMARY.md
@.planning/phases/01-security-foundation/01-01-SUMMARY.md
@apps/orchestrator_3_stream/backend/modules/encryption_service.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create SQLAlchemy ORM models with EncryptedString TypeDecorator</name>
  <files>apps/orchestrator_3_stream/backend/modules/user_models.py</files>
  <action>
Create new file with SQLAlchemy ORM models for user accounts and credentials.

**EncryptedString TypeDecorator:**
```python
from sqlalchemy import TypeDecorator, String
from modules.encryption_service import get_encryption_service

class EncryptedString(TypeDecorator):
    """
    SQLAlchemy TypeDecorator for transparent encryption/decryption.

    Uses Fernet encryption from Phase 1's encryption_service.
    Encrypts on INSERT/UPDATE, decrypts on SELECT.

    Example:
        class MyModel(Base):
            api_key = Column(EncryptedString(500))  # Stored encrypted
    """
    impl = String
    cache_ok = True  # Safe to cache type; encryption service is singleton

    def __init__(self, length=None):
        """Initialize with optional length for database column."""
        super().__init__()
        if length:
            self.impl = String(length)

    def process_bind_param(self, value, dialect):
        """Encrypt plaintext value before storing in database."""
        if value is None:
            return None
        service = get_encryption_service()
        return service.encrypt(str(value))

    def process_result_value(self, value, dialect):
        """Decrypt ciphertext value when reading from database."""
        if value is None:
            return None
        service = get_encryption_service()
        return service.decrypt(value)
```

**UserAccountORM model:**
```python
from sqlalchemy import Column, String, Boolean, DateTime, ForeignKey, Index
from sqlalchemy.dialects.postgresql import UUID as PGUUID
from sqlalchemy.orm import declarative_base, relationship
from datetime import datetime
from uuid import uuid4

Base = declarative_base()

class UserAccountORM(Base):
    """SQLAlchemy ORM model for user_accounts table."""
    __tablename__ = "user_accounts"

    id = Column(PGUUID(as_uuid=True), primary_key=True, default=uuid4)
    user_id = Column(String(255), nullable=False, unique=True)  # FK to user.id
    account_name = Column(String(255), nullable=False)
    is_active = Column(Boolean, default=True)
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)

    # Relationship to credentials
    credentials = relationship("UserCredentialORM", back_populates="account", cascade="all, delete-orphan")

    __table_args__ = (
        Index('idx_user_accounts_user_id', 'user_id'),
    )
```

**UserCredentialORM model:**
```python
class UserCredentialORM(Base):
    """SQLAlchemy ORM model for user_credentials table with encrypted columns."""
    __tablename__ = "user_credentials"

    id = Column(PGUUID(as_uuid=True), primary_key=True, default=uuid4)
    user_account_id = Column(PGUUID(as_uuid=True), ForeignKey('user_accounts.id', ondelete='CASCADE'), nullable=False)
    user_id = Column(String(255), nullable=False)  # Denormalized for RLS
    credential_type = Column(String(50), nullable=False)  # "alpaca", "polygon"
    api_key = Column(EncryptedString(500), nullable=False)  # Auto-encrypted
    secret_key = Column(EncryptedString(500), nullable=False)  # Auto-encrypted
    is_active = Column(Boolean, default=True)
    expires_at = Column(DateTime, nullable=True)
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)

    # Relationship back to account
    account = relationship("UserAccountORM", back_populates="credentials")

    __table_args__ = (
        Index('idx_user_credentials_user_id', 'user_id'),
        Index('idx_user_credentials_account_id', 'user_account_id'),
    )
```

Include:
- Module docstring explaining purpose and encryption behavior
- All imports at top (sqlalchemy, uuid, datetime, encryption_service)
- __all__ export list
  </action>
  <verify>
Import test: `python -c "from modules.user_models import UserAccountORM, UserCredentialORM, EncryptedString; print('Models imported')"`
TypeDecorator test: Verify EncryptedString has process_bind_param and process_result_value methods
  </verify>
  <done>
user_models.py exists with EncryptedString TypeDecorator and ORM models.
Models use EncryptedString for api_key and secret_key columns.
Relationships defined between UserAccountORM and UserCredentialORM.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create comprehensive tests for credential encryption</name>
  <files>apps/orchestrator_3_stream/backend/tests/test_user_credentials.py</files>
  <action>
Create test file verifying encryption behavior and database integration.

**Test structure:**
```python
"""
Tests for user credentials with encryption.

Tests verify:
1. EncryptedString TypeDecorator encrypts/decrypts correctly
2. Credentials stored encrypted in database (not plaintext)
3. Round-trip encryption works for Alpaca key formats
4. Edge cases (empty strings, special characters) handled
"""
import pytest
import os
from uuid import uuid4

# Test encryption round-trip without database
class TestEncryptedStringTypeDecorator:
    """Test EncryptedString TypeDecorator in isolation."""

    def test_encrypt_decrypt_round_trip(self, monkeypatch):
        """Verify encrypt then decrypt returns original value."""
        # Set up encryption key for test
        monkeypatch.setenv("ENCRYPTION_KEY", "test-key-base64...")

        from modules.user_models import EncryptedString
        from modules.encryption_service import get_encryption_service

        type_decorator = EncryptedString(500)

        test_values = [
            "PK0123456789ABCDEF",  # Alpaca API key format
            "sp0123456789abcdefghijklmnop",  # Alpaca secret format
            "special!@#$%^&*()chars",  # Special characters
        ]

        for plaintext in test_values:
            encrypted = type_decorator.process_bind_param(plaintext, None)
            decrypted = type_decorator.process_result_value(encrypted, None)
            assert decrypted == plaintext, f"Round-trip failed: {plaintext}"

    def test_none_handling(self, monkeypatch):
        """Verify None values pass through unchanged."""
        monkeypatch.setenv("ENCRYPTION_KEY", "test-key...")

        from modules.user_models import EncryptedString

        type_decorator = EncryptedString(500)

        assert type_decorator.process_bind_param(None, None) is None
        assert type_decorator.process_result_value(None, None) is None

    def test_encrypted_value_different_from_plaintext(self, monkeypatch):
        """Verify encrypted value is not the same as plaintext."""
        monkeypatch.setenv("ENCRYPTION_KEY", "test-key...")

        from modules.user_models import EncryptedString

        type_decorator = EncryptedString(500)
        plaintext = "my-secret-api-key"

        encrypted = type_decorator.process_bind_param(plaintext, None)

        assert encrypted != plaintext, "Encrypted value should differ from plaintext"
        assert len(encrypted) > len(plaintext), "Encrypted value should be longer"


class TestAlpacaCredentialFormats:
    """Test with real Alpaca credential format patterns."""

    def test_alpaca_api_key_format(self, monkeypatch):
        """Test Alpaca API key format: PK followed by alphanumeric."""
        monkeypatch.setenv("ENCRYPTION_KEY", "test-key...")

        from modules.encryption_service import get_encryption_service

        service = get_encryption_service()

        # Real Alpaca key patterns
        api_keys = [
            "PKABCDEF1234567890",  # Live key format
            "PKTEST12345678901",   # Test key format
        ]

        for key in api_keys:
            encrypted = service.encrypt(key)
            decrypted = service.decrypt(encrypted)
            assert decrypted == key

    def test_alpaca_secret_key_format(self, monkeypatch):
        """Test Alpaca secret key format: lowercase alphanumeric."""
        monkeypatch.setenv("ENCRYPTION_KEY", "test-key...")

        from modules.encryption_service import get_encryption_service

        service = get_encryption_service()

        # Real Alpaca secret patterns
        secrets = [
            "abcdefghijklmnopqrstuvwxyz1234567890",
            "sp1234567890abcdefghijklmnopqrstuv",
        ]

        for secret in secrets:
            encrypted = service.encrypt(secret)
            decrypted = service.decrypt(encrypted)
            assert decrypted == secret
```

**Database integration tests (require real DB):**
```python
class TestCredentialDatabaseIntegration:
    """Integration tests with actual database (requires DATABASE_URL)."""

    @pytest.mark.skipif(
        not os.getenv("DATABASE_URL"),
        reason="DATABASE_URL not set"
    )
    def test_credential_stored_encrypted_in_db(self):
        """Verify credential is encrypted when stored in database."""
        # This test requires actual database connection
        # Creates credential, then queries raw SQL to verify encryption
        pass  # Implementation depends on database setup
```

Include:
- Fixtures for encryption key setup using monkeypatch
- Clear test docstrings explaining what each test verifies
- Test isolation (each test sets its own environment)
- Skip markers for tests requiring database
  </action>
  <verify>
Run tests: `cd apps/orchestrator_3_stream/backend && uv run pytest tests/test_user_credentials.py -v`
All tests pass with ENCRYPTION_KEY set
  </verify>
  <done>
Test file exists with comprehensive tests for:
- EncryptedString TypeDecorator round-trip encryption
- None value handling
- Alpaca-specific key formats (PK..., sp...)
- Verification that encrypted value differs from plaintext
Tests pass when run with uv run pytest.
  </done>
</task>

</tasks>

<verification>
1. user_models.py exists at apps/orchestrator_3_stream/backend/modules/user_models.py
2. EncryptedString TypeDecorator class exists with process_bind_param and process_result_value
3. UserAccountORM and UserCredentialORM classes exist
4. UserCredentialORM.api_key and secret_key columns use EncryptedString type
5. test_user_credentials.py exists with comprehensive tests
6. Tests cover round-trip encryption, None handling, Alpaca formats
7. All tests pass: `uv run pytest tests/test_user_credentials.py`
8. EncryptedString uses get_encryption_service() from Phase 1
</verification>

<success_criteria>
- EncryptedString transparently encrypts credentials on INSERT/UPDATE
- EncryptedString transparently decrypts credentials on SELECT
- ORM models match database schema from Plan 01
- Relationships between UserAccountORM and UserCredentialORM work correctly
- Tests verify encryption behavior for Alpaca credential formats
- Tests pass in isolated environment (monkeypatch for ENCRYPTION_KEY)
</success_criteria>

<output>
After completion, create `.planning/phases/02-database-schema/02-03-SUMMARY.md`
</output>
