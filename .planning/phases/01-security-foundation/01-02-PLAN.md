---
phase: 01-security-foundation
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/orchestrator_3_stream/backend/modules/logger.py
  - .pre-commit-config.yaml
  - .secrets.baseline
autonomous: true

must_haves:
  truths:
    - "API credentials are redacted from log output"
    - "Pre-commit hook detects secrets before they are committed"
    - "Alpaca-format keys (PK..., sp...) are masked in logs"
    - "Credentials in exception tracebacks are redacted"
  artifacts:
    - path: "apps/orchestrator_3_stream/backend/modules/logger.py"
      provides: "CredentialRedactionFilter class"
      contains: "CredentialRedactionFilter"
      min_lines: 30
    - path: ".pre-commit-config.yaml"
      provides: "detect-secrets hook configuration"
      contains: "detect-secrets"
    - path: ".secrets.baseline"
      provides: "Baseline for detect-secrets (empty or with known false positives)"
  key_links:
    - from: "apps/orchestrator_3_stream/backend/modules/logger.py"
      to: "logging.Filter"
      via: "CredentialRedactionFilter inherits from logging.Filter"
      pattern: "class CredentialRedactionFilter.*Filter"
    - from: "apps/orchestrator_3_stream/backend/modules/logger.py"
      to: "OrchestratorLogger"
      via: "Filter added to logger handlers"
      pattern: "addFilter"
---

<objective>
Implement log security measures to prevent credential leakage and pre-commit hooks to prevent accidental secret commits.

Purpose: Credentials must never appear in logs (CRED-03 requirement) and secrets must be blocked from entering version control. These are defense-in-depth measures.

Output: A log redaction filter that masks credentials in all log output, and a pre-commit hook that blocks commits containing secrets.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-security-foundation/01-RESEARCH.md

# Existing file to modify
@apps/orchestrator_3_stream/backend/modules/logger.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add CredentialRedactionFilter to logger.py</name>
  <files>apps/orchestrator_3_stream/backend/modules/logger.py</files>
  <action>
Add a CredentialRedactionFilter class to logger.py and integrate it with the OrchestratorLogger:

1. **Add imports at top** (after existing imports):
```python
import re
```

2. **Add CredentialRedactionFilter class** (before OrchestratorLogger class):
```python
class CredentialRedactionFilter(logging.Filter):
    """
    Redacts API credentials from log records to prevent accidental exposure.
    Matches common credential formats and replaces with masked values.
    """

    # Patterns to match various credential formats
    REDACTION_PATTERNS = [
        # Environment variable formats
        (r'ALPACA_API_KEY\s*=\s*[\w\-\.]+', 'ALPACA_API_KEY=***'),
        (r'ALPACA_SECRET_KEY\s*=\s*[\w\-\.]+', 'ALPACA_SECRET_KEY=***'),
        (r'API_KEY\s*=\s*[\w\-\.]+', 'API_KEY=***'),
        (r'SECRET_KEY\s*=\s*[\w\-\.]+', 'SECRET_KEY=***'),
        (r'ENCRYPTION_KEY\s*=\s*[\w\-\.\/\+]+', 'ENCRYPTION_KEY=***'),

        # JSON/dict formats
        (r'"api[_-]?key"\s*:\s*"[^"]*"', '"api_key":"***"'),
        (r'"secret[_-]?key"\s*:\s*"[^"]*"', '"secret_key":"***"'),
        (r"'api[_-]?key'\s*:\s*'[^']*'", "'api_key':'***'"),
        (r"'secret[_-]?key'\s*:\s*'[^']*'", "'secret_key':'***'"),

        # Query string and URL formats
        (r'[?&]api[_-]?key=[^&\s]*', '?api_key=***'),
        (r'Bearer\s+[\w\-\.]+', 'Bearer ***'),

        # Alpaca-specific key formats (PK... for API key, sp... for secret)
        (r'\bPK[\w]{17,}\b', 'PK***'),
        (r'\bsp[\w]{28,}\b', 'sp***'),

        # Generic high-entropy strings that look like API keys (20+ alphanumeric)
        (r'["\'][\w\-]{32,}["\']', '"***"'),
    ]

    def filter(self, record: logging.LogRecord) -> bool:
        """
        Filter a log record to redact credentials.

        Args:
            record: LogRecord to filter

        Returns:
            True (always allow record to be logged, but redacted)
        """
        # Redact message
        if record.msg:
            record.msg = self._redact_string(str(record.msg))

        # Redact formatted args
        try:
            if record.args:
                if isinstance(record.args, dict):
                    record.args = {k: self._redact_string(str(v)) for k, v in record.args.items()}
                else:
                    record.args = tuple(self._redact_string(str(arg)) for arg in record.args)
        except Exception:
            pass  # Don't break logging if args redaction fails

        # Redact exception traceback
        if record.exc_text:
            record.exc_text = self._redact_string(record.exc_text)

        return True

    def _redact_string(self, text: str) -> str:
        """Apply all redaction patterns to text"""
        for pattern, replacement in self.REDACTION_PATTERNS:
            text = re.sub(pattern, replacement, text, flags=re.IGNORECASE)
        return text
```

3. **Integrate with OrchestratorLogger** - In the `__init__` method, after adding handlers, add the redaction filter to ALL handlers:
```python
        # Add credential redaction filter to all handlers
        redaction_filter = CredentialRedactionFilter()
        for handler in self.logger.handlers:
            handler.addFilter(redaction_filter)
```

This ensures credentials are redacted in both console AND file output.
  </action>
  <verify>
```bash
cd /Users/muzz/Desktop/tac/TOD/apps/orchestrator_3_stream/backend
python -c "
from modules.logger import CredentialRedactionFilter, OrchestratorLogger
import logging

# Test the filter directly
f = CredentialRedactionFilter()
record = logging.LogRecord('test', logging.INFO, '', 0, 'API_KEY=abc123xyz', (), None)
f.filter(record)
assert 'abc123xyz' not in record.msg, f'API_KEY not redacted: {record.msg}'
assert 'API_KEY=***' in record.msg, f'Expected API_KEY=***: {record.msg}'
print('Filter test PASSED')
"
```
  </verify>
  <done>
- CredentialRedactionFilter class exists in logger.py
- Filter has patterns for ALPACA_API_KEY, ALPACA_SECRET_KEY, ENCRYPTION_KEY
- Filter handles JSON formats, URL formats, Bearer tokens
- Filter handles Alpaca-specific formats (PK..., sp...)
- OrchestratorLogger applies filter to all handlers (console + file)
  </done>
</task>

<task type="auto">
  <name>Task 2: Create pre-commit hook configuration</name>
  <files>.pre-commit-config.yaml</files>
  <action>
Create a pre-commit configuration file at the repository root that includes detect-secrets:

1. **Create .pre-commit-config.yaml** at `/Users/muzz/Desktop/tac/TOD/.pre-commit-config.yaml`:
```yaml
# Pre-commit hooks for security and code quality
# Install: pip install pre-commit && pre-commit install
# Run manually: pre-commit run --all-files

repos:
  # Detect secrets before they get committed
  - repo: https://github.com/Yelp/detect-secrets
    rev: v1.4.0
    hooks:
      - id: detect-secrets
        name: detect-secrets
        args:
          - --baseline
          - .secrets.baseline
        exclude: |
          (?x)^(
            .*\.lock$|
            .*-lock\.json$|
            \.secrets\.baseline$
          )$
```

This configuration:
- Uses detect-secrets v1.4.0 (stable, well-tested)
- References a baseline file for known false positives
- Excludes lock files which often trigger false positives
  </action>
  <verify>
```bash
cat /Users/muzz/Desktop/tac/TOD/.pre-commit-config.yaml | grep -q "detect-secrets" && echo "detect-secrets hook configured"
```
  </verify>
  <done>
- .pre-commit-config.yaml exists at repository root
- detect-secrets hook is configured with v1.4.0
- Baseline file path is specified
- Lock files are excluded from scanning
  </done>
</task>

<task type="auto">
  <name>Task 3: Create secrets baseline file</name>
  <files>.secrets.baseline</files>
  <action>
Create an initial secrets baseline file. This file tracks known false positives so they don't block commits.

1. **Create .secrets.baseline** at `/Users/muzz/Desktop/tac/TOD/.secrets.baseline`:
```json
{
  "version": "1.4.0",
  "plugins_used": [
    {"name": "ArtifactoryDetector"},
    {"name": "AWSKeyDetector"},
    {"name": "AzureStorageKeyDetector"},
    {"name": "Base64HighEntropyString", "limit": 4.5},
    {"name": "BasicAuthDetector"},
    {"name": "CloudantDetector"},
    {"name": "DiscordBotTokenDetector"},
    {"name": "GitHubTokenDetector"},
    {"name": "HexHighEntropyString", "limit": 3.0},
    {"name": "IbmCloudIamDetector"},
    {"name": "IbmCosHmacDetector"},
    {"name": "JwtTokenDetector"},
    {"name": "KeywordDetector", "keyword_exclude": ""},
    {"name": "MailchimpDetector"},
    {"name": "NpmDetector"},
    {"name": "PrivateKeyDetector"},
    {"name": "SendGridDetector"},
    {"name": "SlackDetector"},
    {"name": "SoftlayerDetector"},
    {"name": "SquareOAuthDetector"},
    {"name": "StripeDetector"},
    {"name": "TwilioKeyDetector"}
  ],
  "filters_used": [
    {"path": "detect_secrets.filters.allowlist.is_line_allowlisted"},
    {"path": "detect_secrets.filters.common.is_baseline_file", "filename": ".secrets.baseline"},
    {"path": "detect_secrets.filters.common.is_ignored_due_to_verification_policies", "min_level": 2},
    {"path": "detect_secrets.filters.heuristic.is_indirect_reference"},
    {"path": "detect_secrets.filters.heuristic.is_likely_id_string"},
    {"path": "detect_secrets.filters.heuristic.is_lock_file"},
    {"path": "detect_secrets.filters.heuristic.is_not_alphanumeric_string"},
    {"path": "detect_secrets.filters.heuristic.is_potential_uuid"},
    {"path": "detect_secrets.filters.heuristic.is_prefixed_with_dollar_sign"},
    {"path": "detect_secrets.filters.heuristic.is_sequential_string"},
    {"path": "detect_secrets.filters.heuristic.is_swagger_file"},
    {"path": "detect_secrets.filters.heuristic.is_templated_secret"}
  ],
  "results": {},
  "generated_at": "2026-01-29T00:00:00Z"
}
```

2. **After creating**, run detect-secrets to scan the codebase and update the baseline (this will catch any existing false positives):
```bash
cd /Users/muzz/Desktop/tac/TOD
# Install detect-secrets if not present
uv pip install detect-secrets 2>/dev/null || pip install detect-secrets
# Scan and update baseline
detect-secrets scan --baseline .secrets.baseline . || true
```

Note: Some warnings about existing secrets (like in .env.sample placeholder) are expected and should be tracked in the baseline.
  </action>
  <verify>
```bash
test -f /Users/muzz/Desktop/tac/TOD/.secrets.baseline && echo ".secrets.baseline exists"
cat /Users/muzz/Desktop/tac/TOD/.secrets.baseline | python -c "import json, sys; json.load(sys.stdin); print('Valid JSON')"
```
  </verify>
  <done>
- .secrets.baseline exists at repository root
- File contains valid JSON with detect-secrets configuration
- Baseline is ready for detect-secrets to track false positives
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. **Log redaction test** (comprehensive):
```bash
cd /Users/muzz/Desktop/tac/TOD/apps/orchestrator_3_stream/backend
python -c "
from modules.logger import CredentialRedactionFilter
import logging

# Test various credential formats
test_cases = [
    ('ALPACA_API_KEY=PKabc123def456', 'ALPACA_API_KEY=***'),
    ('ALPACA_SECRET_KEY=spXYZ789longersecret', 'ALPACA_SECRET_KEY=***'),
    ('Bearer eyJhbGciOiJIUzI1NiJ9', 'Bearer ***'),
    ('{\"api_key\": \"secret123\"}', '{\"api_key\":\"***\"}'),
    ('PK0123456789ABCDEFGH', 'PK***'),
    ('sp0123456789abcdefghijklmnopqrst', 'sp***'),
]

f = CredentialRedactionFilter()
all_passed = True
for original, expected_pattern in test_cases:
    record = logging.LogRecord('test', logging.INFO, '', 0, original, (), None)
    f.filter(record)
    # Check that sensitive part is redacted
    if '***' not in record.msg:
        print(f'FAILED: {original} -> {record.msg} (expected redaction)')
        all_passed = False
    else:
        print(f'OK: {original[:30]}... -> {record.msg[:30]}...')

if all_passed:
    print('\\nAll redaction tests PASSED')
else:
    print('\\nSome tests FAILED')
    exit(1)
"
```

2. **Pre-commit config validation**:
```bash
cd /Users/muzz/Desktop/tac/TOD
cat .pre-commit-config.yaml
cat .secrets.baseline | head -20
```

3. **Pre-commit install check** (optional, user may not have pre-commit installed):
```bash
cd /Users/muzz/Desktop/tac/TOD
which pre-commit && pre-commit run detect-secrets --all-files || echo "Pre-commit not installed (install with: pip install pre-commit && pre-commit install)"
```
</verification>

<success_criteria>
- [ ] CredentialRedactionFilter class exists in logger.py
- [ ] Filter redacts ALPACA_API_KEY, ALPACA_SECRET_KEY, ENCRYPTION_KEY patterns
- [ ] Filter redacts Alpaca-specific formats (PK..., sp...)
- [ ] Filter handles JSON, URL, Bearer token formats
- [ ] OrchestratorLogger applies filter to all handlers
- [ ] .pre-commit-config.yaml exists with detect-secrets hook
- [ ] .secrets.baseline exists with valid JSON configuration
</success_criteria>

<output>
After completion, create `.planning/phases/01-security-foundation/01-02-SUMMARY.md`
</output>
