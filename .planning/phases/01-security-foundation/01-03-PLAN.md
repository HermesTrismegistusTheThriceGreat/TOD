---
phase: 01-security-foundation
plan: 03
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - apps/orchestrator_3_stream/backend/tests/test_encryption_service.py
autonomous: false

must_haves:
  truths:
    - "Round-trip encryption test passes (encrypt -> decrypt -> equals original)"
    - "Empty string handling works correctly"
    - "Special characters in credentials are preserved"
    - "Missing ENCRYPTION_KEY raises appropriate error"
    - "Log audit confirms no credentials in log output"
  artifacts:
    - path: "apps/orchestrator_3_stream/backend/tests/test_encryption_service.py"
      provides: "Comprehensive encryption service tests"
      contains: "test_encryption_round_trip"
      min_lines: 50
  key_links:
    - from: "apps/orchestrator_3_stream/backend/tests/test_encryption_service.py"
      to: "apps/orchestrator_3_stream/backend/modules/encryption_service.py"
      via: "imports CredentialEncryptionService"
      pattern: "from modules.encryption_service import"
---

<objective>
Write comprehensive tests for the encryption service and perform final phase verification.

Purpose: Phase 1 success criteria require round-trip tests to pass and log audit to confirm no credential leakage. This plan validates the entire security foundation.

Output: Test suite for encryption service, plus verification that all Phase 1 success criteria are met.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-security-foundation/01-RESEARCH.md
@.planning/phases/01-security-foundation/01-01-SUMMARY.md

# Files created in Plan 01 that we're testing
@apps/orchestrator_3_stream/backend/modules/encryption_service.py
@apps/orchestrator_3_stream/backend/modules/logger.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create encryption service test suite</name>
  <files>apps/orchestrator_3_stream/backend/tests/test_encryption_service.py</files>
  <action>
Create comprehensive tests for the encryption service at `apps/orchestrator_3_stream/backend/tests/test_encryption_service.py`:

```python
#!/usr/bin/env python3
"""
Tests for CredentialEncryptionService

Tests encryption round-trip, edge cases, and error handling per Phase 1 requirements.
Run with: cd apps/orchestrator_3_stream/backend && uv run pytest tests/test_encryption_service.py -v
"""

import os
import pytest
from cryptography.fernet import Fernet, InvalidToken


class TestCredentialEncryptionService:
    """Tests for CredentialEncryptionService"""

    @pytest.fixture(autouse=True)
    def setup_encryption_key(self, monkeypatch):
        """Set up a test encryption key for each test"""
        test_key = Fernet.generate_key().decode()
        monkeypatch.setenv("ENCRYPTION_KEY", test_key)
        # Clear any cached service instance
        import modules.encryption_service as enc_module
        enc_module._encryption_service_instance = None

    def test_encryption_round_trip_basic(self):
        """Test basic encrypt -> decrypt returns original value"""
        from modules.encryption_service import get_encryption_service

        service = get_encryption_service()
        original = "test-api-key-123"

        encrypted = service.encrypt(original)
        decrypted = service.decrypt(encrypted)

        assert decrypted == original
        assert encrypted != original  # Should be different

    def test_encryption_round_trip_alpaca_format(self):
        """Test round-trip with Alpaca-style API keys"""
        from modules.encryption_service import get_encryption_service

        service = get_encryption_service()

        # Typical Alpaca API key format
        api_key = "PKABCDEF1234567890"
        encrypted = service.encrypt(api_key)
        decrypted = service.decrypt(encrypted)
        assert decrypted == api_key

        # Typical Alpaca secret key format
        secret_key = "sp0123456789abcdefghijklmnopqrstuvwxyz"
        encrypted = service.encrypt(secret_key)
        decrypted = service.decrypt(encrypted)
        assert decrypted == secret_key

    def test_encryption_round_trip_special_characters(self):
        """Test round-trip preserves special characters"""
        from modules.encryption_service import get_encryption_service

        service = get_encryption_service()
        test_cases = [
            "key!@#$%^&*()",
            "key with spaces",
            "key\twith\ttabs",
            "key\nwith\nnewlines",
            "unicode: \u00e9\u00e0\u00fc",
            "emoji: \U0001F680",
        ]

        for original in test_cases:
            encrypted = service.encrypt(original)
            decrypted = service.decrypt(encrypted)
            assert decrypted == original, f"Failed for: {repr(original)}"

    def test_empty_string_handling(self):
        """Test that empty strings are handled correctly"""
        from modules.encryption_service import get_encryption_service

        service = get_encryption_service()

        # Empty string should return empty string
        encrypted = service.encrypt("")
        assert encrypted == ""

        decrypted = service.decrypt("")
        assert decrypted == ""

    def test_none_input_raises_error(self):
        """Test that None input raises ValueError"""
        from modules.encryption_service import get_encryption_service

        service = get_encryption_service()

        with pytest.raises(ValueError, match="Cannot encrypt None"):
            service.encrypt(None)

    def test_invalid_ciphertext_raises_error(self):
        """Test that corrupted ciphertext raises InvalidToken"""
        from modules.encryption_service import get_encryption_service

        service = get_encryption_service()

        with pytest.raises(InvalidToken):
            service.decrypt("not-valid-ciphertext")

    def test_ciphertext_is_different_each_time(self):
        """Test that encrypting same value produces different ciphertext (IV changes)"""
        from modules.encryption_service import get_encryption_service

        service = get_encryption_service()
        original = "test-credential"

        encrypted1 = service.encrypt(original)
        encrypted2 = service.encrypt(original)

        # Fernet uses random IV, so ciphertext should differ
        assert encrypted1 != encrypted2

        # But both should decrypt to same value
        assert service.decrypt(encrypted1) == original
        assert service.decrypt(encrypted2) == original

    def test_singleton_returns_same_instance(self):
        """Test that get_encryption_service returns singleton"""
        from modules.encryption_service import get_encryption_service

        service1 = get_encryption_service()
        service2 = get_encryption_service()

        assert service1 is service2


class TestEncryptionKeyValidation:
    """Tests for encryption key validation"""

    def test_missing_encryption_key_raises_error(self, monkeypatch):
        """Test that missing ENCRYPTION_KEY raises ValueError"""
        monkeypatch.delenv("ENCRYPTION_KEY", raising=False)

        # Clear cached instance
        import modules.encryption_service as enc_module
        enc_module._encryption_service_instance = None

        from modules.encryption_service import CredentialEncryptionService

        with pytest.raises(ValueError, match="ENCRYPTION_KEY"):
            CredentialEncryptionService()

    def test_invalid_encryption_key_raises_error(self, monkeypatch):
        """Test that invalid ENCRYPTION_KEY raises ValueError"""
        monkeypatch.setenv("ENCRYPTION_KEY", "not-a-valid-fernet-key")

        # Clear cached instance
        import modules.encryption_service as enc_module
        enc_module._encryption_service_instance = None

        from modules.encryption_service import CredentialEncryptionService

        with pytest.raises(ValueError, match="Invalid ENCRYPTION_KEY"):
            CredentialEncryptionService()


class TestLogRedaction:
    """Tests for credential redaction in logs"""

    def test_api_key_redacted_in_logs(self):
        """Test that API keys are redacted from log output"""
        from modules.logger import CredentialRedactionFilter
        import logging

        filter = CredentialRedactionFilter()

        test_cases = [
            ("ALPACA_API_KEY=PKabc123def456ghi", "***"),
            ("ALPACA_SECRET_KEY=sp0123456789abcdef", "***"),
            ("ENCRYPTION_KEY=abcdefghijklmnop", "***"),
            ('{"api_key": "secret123"}', "***"),
            ("Bearer eyJhbGciOiJIUzI1NiJ9.xxx", "***"),
        ]

        for message, expected_mask in test_cases:
            record = logging.LogRecord("test", logging.INFO, "", 0, message, (), None)
            filter.filter(record)
            # Check that original sensitive value is not in output
            assert expected_mask in record.msg, f"Not redacted: {message} -> {record.msg}"

    def test_alpaca_key_formats_redacted(self):
        """Test that Alpaca-specific key formats are redacted"""
        from modules.logger import CredentialRedactionFilter
        import logging

        filter = CredentialRedactionFilter()

        # Alpaca API key format: PK followed by 17+ alphanumeric
        api_key_msg = "Using key PK0123456789ABCDEFGH for trading"
        record = logging.LogRecord("test", logging.INFO, "", 0, api_key_msg, (), None)
        filter.filter(record)
        assert "PK0123456789ABCDEFGH" not in record.msg
        assert "PK***" in record.msg

        # Alpaca secret key format: sp followed by 28+ alphanumeric
        secret_key_msg = "Secret: sp0123456789abcdefghijklmnopqrst"
        record = logging.LogRecord("test", logging.INFO, "", 0, secret_key_msg, (), None)
        filter.filter(record)
        assert "sp0123456789abcdefghijklmnopqrst" not in record.msg
        assert "sp***" in record.msg
```

The tests cover:
1. Basic round-trip encryption/decryption
2. Alpaca-specific key formats
3. Special characters and Unicode
4. Empty string handling
5. Error cases (None input, invalid ciphertext, missing key)
6. Ciphertext uniqueness (Fernet IV)
7. Singleton pattern
8. Log redaction patterns
  </action>
  <verify>
```bash
cd /Users/muzz/Desktop/tac/TOD/apps/orchestrator_3_stream/backend
# Generate a test key and run tests
ENCRYPTION_KEY=$(python -c "from cryptography.fernet import Fernet; print(Fernet.generate_key().decode())") \
uv run pytest tests/test_encryption_service.py -v
```
  </verify>
  <done>
- test_encryption_service.py exists with comprehensive test suite
- Tests cover round-trip encryption/decryption
- Tests cover edge cases (empty string, special characters)
- Tests cover error handling (None input, missing key, invalid key)
- Tests cover log redaction patterns
- All tests pass
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 2: Verify Phase 1 Success Criteria</name>
  <what-built>
Complete Phase 1 security foundation:
1. CredentialEncryptionService with encrypt/decrypt methods
2. Log redaction filter that masks credentials
3. Pre-commit hook configuration for detect-secrets
4. Test suite validating all functionality
  </what-built>
  <how-to-verify>
**Verify each Phase 1 success criterion:**

1. **Fernet encryption key loads from environment variable on server start**
   ```bash
   cd /Users/muzz/Desktop/tac/TOD/apps/orchestrator_3_stream/backend
   # Without key - should show warning
   unset ENCRYPTION_KEY
   python -c "from modules.config import ENCRYPTION_KEY; print(f'Key set: {bool(ENCRYPTION_KEY)}')"

   # With key - should load successfully
   export ENCRYPTION_KEY=$(python -c "from cryptography.fernet import Fernet; print(Fernet.generate_key().decode())")
   python -c "from modules.config import ENCRYPTION_KEY; print(f'Key set: {bool(ENCRYPTION_KEY)}')"
   ```

2. **Credential values are encrypted/decrypted correctly in round-trip tests**
   ```bash
   cd /Users/muzz/Desktop/tac/TOD/apps/orchestrator_3_stream/backend
   ENCRYPTION_KEY=$(python -c "from cryptography.fernet import Fernet; print(Fernet.generate_key().decode())") \
   uv run pytest tests/test_encryption_service.py -v -k "round_trip"
   ```

3. **API credentials never appear in application logs**
   ```bash
   cd /Users/muzz/Desktop/tac/TOD/apps/orchestrator_3_stream/backend
   python -c "
   from modules.logger import get_logger, CredentialRedactionFilter
   import logging

   # Test that credentials are redacted
   logger = get_logger()
   test_msg = 'Connecting with ALPACA_API_KEY=PKTEST123456789ABC'
   logger.info(test_msg)
   print('Check console output above - key should be masked as PK***')
   "
   ```

4. **Pre-commit hook blocks commits containing secrets**
   ```bash
   cd /Users/muzz/Desktop/tac/TOD
   # Verify config exists
   cat .pre-commit-config.yaml
   cat .secrets.baseline | head -10

   # Test hook (requires pre-commit installed)
   pip install pre-commit 2>/dev/null
   pre-commit run detect-secrets --all-files || echo "Some secrets detected (expected for sample files)"
   ```

**Expected outcomes:**
- All pytest tests pass
- Credentials are masked in log output (shows *** instead of actual values)
- Pre-commit config files exist and are valid
  </how-to-verify>
  <resume-signal>Type "approved" if all success criteria pass, or describe any issues found</resume-signal>
</task>

</tasks>

<verification>
Phase 1 is complete when ALL success criteria are verified:

1. **Encryption key loading**: `python -c "from modules.config import ENCRYPTION_KEY"` works
2. **Round-trip tests pass**: `uv run pytest tests/test_encryption_service.py -v` shows all green
3. **Log redaction works**: Credentials are masked in console output
4. **Pre-commit configured**: `.pre-commit-config.yaml` and `.secrets.baseline` exist

Run full verification:
```bash
cd /Users/muzz/Desktop/tac/TOD/apps/orchestrator_3_stream/backend
ENCRYPTION_KEY=$(python -c "from cryptography.fernet import Fernet; print(Fernet.generate_key().decode())") \
uv run pytest tests/test_encryption_service.py -v

# Check files exist
ls -la /Users/muzz/Desktop/tac/TOD/.pre-commit-config.yaml
ls -la /Users/muzz/Desktop/tac/TOD/.secrets.baseline
ls -la modules/encryption_service.py
```
</verification>

<success_criteria>
- [ ] test_encryption_service.py exists with comprehensive tests
- [ ] All encryption round-trip tests pass
- [ ] All edge case tests pass (empty string, special chars)
- [ ] All error handling tests pass (None, missing key, invalid key)
- [ ] All log redaction tests pass
- [ ] Human verification confirms all Phase 1 success criteria met
</success_criteria>

<output>
After completion, create `.planning/phases/01-security-foundation/01-03-SUMMARY.md`
</output>
