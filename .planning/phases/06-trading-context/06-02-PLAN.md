---
phase: 06-trading-context
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/orchestrator_3_stream/backend/main.py
  - apps/orchestrator_3_stream/backend/modules/alpaca_service.py
autonomous: true

must_haves:
  truths:
    - "Positions endpoint requires credential_id query parameter"
    - "Positions are fetched using decrypted credentials from selected account"
    - "User cannot fetch positions for credentials they don't own"
  artifacts:
    - path: "apps/orchestrator_3_stream/backend/main.py"
      provides: "Positions endpoint with credential_id parameter"
      contains: "credential_id: str = Query"
    - path: "apps/orchestrator_3_stream/backend/modules/alpaca_service.py"
      provides: "get_all_positions accepting credentials"
      contains: "get_all_positions_with_credential"
  key_links:
    - from: "main.py get_positions"
      to: "get_connection_with_rls"
      via: "RLS context establishment"
      pattern: "get_connection_with_rls.*user"
    - from: "main.py get_positions"
      to: "get_decrypted_alpaca_credential"
      via: "credential decryption"
      pattern: "get_decrypted_alpaca_credential.*credential_id"
    - from: "alpaca_service.py"
      to: "TradingClient"
      via: "credential injection"
      pattern: "TradingClient.*api_key"
---

<objective>
Add credential context to positions endpoint so users only see positions from their selected account.

Purpose: TRADE-03 requires positions display to show only the selected account's positions, not a global account.
Output: Modified positions endpoint that requires credential_id, validates ownership via RLS, and queries Alpaca with those credentials.
</objective>

<execution_context>
@/Users/muzz/.claude/get-shit-done/workflows/execute-plan.md
@/Users/muzz/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-trading-context/06-RESEARCH.md

# Key existing files
@apps/orchestrator_3_stream/backend/modules/alpaca_service.py
@apps/orchestrator_3_stream/backend/modules/credential_service.py
@apps/orchestrator_3_stream/backend/modules/database.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add get_all_positions_with_credential method to AlpacaService</name>
  <files>apps/orchestrator_3_stream/backend/modules/alpaca_service.py</files>
  <action>
Add a new method to AlpacaService that fetches positions using provided credentials instead of the service's default credentials.

1. First, check the existing get_all_positions method to understand the return type and logic.

2. Add a new method `get_all_positions_with_credential` that accepts api_key and secret_key:

```python
async def get_all_positions_with_credential(
    self,
    api_key: str,
    secret_key: str,
    paper: bool = True
) -> List[IronCondorPosition]:
    """
    Get all iron condor positions using provided credentials.

    This method creates a temporary TradingClient with the provided
    credentials rather than using the service's default credentials.
    Used when credentials come from encrypted storage per-user.

    Args:
        api_key: Decrypted Alpaca API key
        secret_key: Decrypted Alpaca secret key
        paper: Whether to use paper trading endpoint (default True)

    Returns:
        List of IronCondorPosition objects

    Raises:
        Exception: If API call fails
    """
    try:
        self.logger.info("Fetching positions with provided credentials")

        # Create temporary client with provided credentials
        temp_client = TradingClient(
            api_key=api_key,
            secret_key=secret_key,
            paper=paper
        )

        # Get raw positions from Alpaca
        raw_positions = temp_client.get_all_positions()

        # Process into iron condor positions using existing logic
        positions = self._process_positions_to_iron_condors(raw_positions)

        self.logger.info(f"Fetched {len(positions)} iron condor positions with provided credentials")
        return positions

    except Exception as e:
        self.logger.error(f"Failed to get positions with provided credentials: {e}")
        raise
```

Note: This method reuses the existing `_process_positions_to_iron_condors` method (or equivalent processing logic) that the current `get_all_positions` uses. Check the existing implementation to ensure consistent return types.

If `_process_positions_to_iron_condors` doesn't exist as a separate method, extract the position processing logic from `get_all_positions` into a private method first, then call it from both methods.
  </action>
  <verify>
Run: `cd /Users/muzz/Desktop/tac/TOD/apps/orchestrator_3_stream/backend && uv run python -c "from modules.alpaca_service import AlpacaService; print('get_all_positions_with_credential' in dir(AlpacaService))"`
Should print: True
  </verify>
  <done>AlpacaService has get_all_positions_with_credential method accepting api_key and secret_key</done>
</task>

<task type="auto">
  <name>Task 2: Modify positions endpoint to accept credential_id</name>
  <files>apps/orchestrator_3_stream/backend/main.py</files>
  <action>
Modify the `/api/positions` endpoint to:
1. Accept credential_id as a required query parameter
2. Validate credential ownership via RLS
3. Decrypt credentials on-demand
4. Use get_all_positions_with_credential method

Find the existing `get_positions` function (around line 1239) and replace it:

```python
@app.get("/api/positions", response_model=GetPositionsResponse, tags=["Alpaca"])
async def get_positions(
    request: Request,
    credential_id: str = Query(..., description="UUID of credential to fetch positions for")
):
    """
    Get all iron condor positions for the selected credential.

    Validates credential ownership via RLS, decrypts credentials on-demand,
    and fetches positions from Alpaca using those credentials.

    Args:
        credential_id: UUID of the credential (required query parameter)

    Returns:
        GetPositionsResponse with list of iron condor positions

    Raises:
        403: If credential not found or not owned by user
    """
    try:
        logger.http_request("GET", "/api/positions")
        logger.info(f"Positions request for credential: {credential_id}")

        alpaca_service = get_alpaca_service(request.app)

        # For now, use a placeholder user_id until auth integration
        # TODO: Replace with actual user from auth middleware
        user_id = request.headers.get("X-User-ID", "demo-user")

        # Validate credential ownership via RLS and get decrypted credentials
        try:
            async with get_connection_with_rls(user_id) as conn:
                async with get_decrypted_alpaca_credential(
                    conn, credential_id, user_id
                ) as (api_key, secret_key):
                    # Credentials validated - fetch positions with these credentials
                    positions = await alpaca_service.get_all_positions_with_credential(
                        api_key=api_key,
                        secret_key=secret_key,
                        paper=True  # Could be derived from credential_type in future
                    )

                    logger.http_request("GET", "/api/positions", 200)
                    return GetPositionsResponse(
                        status="success",
                        positions=positions,
                        total_count=len(positions)
                    )

        except ValueError as e:
            # Credential not found or not owned by user
            logger.error(f"Credential validation failed: {e}")
            return GetPositionsResponse(
                status="error",
                message=f"Credential access denied: {str(e)}"
            )

    except Exception as e:
        logger.error(f"Failed to get positions: {e}")
        return GetPositionsResponse(
            status="error",
            message=str(e)
        )
```

Also update the individual position endpoint (`/api/positions/{position_id}`) similarly if it exists, to also require credential_id. However, if that endpoint is less critical for Phase 6, it can be deferred.

Ensure the imports from Plan 01 (get_connection_with_rls, get_decrypted_alpaca_credential) are present - they should be added by Plan 01.
  </action>
  <verify>
Check endpoint signature:
`grep -A3 'def get_positions' /Users/muzz/Desktop/tac/TOD/apps/orchestrator_3_stream/backend/main.py | grep -q "credential_id" && echo "credential_id parameter added"`

Check RLS usage:
`grep -B5 -A10 "get_all_positions_with_credential" /Users/muzz/Desktop/tac/TOD/apps/orchestrator_3_stream/backend/main.py | grep -q "get_decrypted_alpaca_credential" && echo "Uses credential decryption"`
  </verify>
  <done>Positions endpoint requires credential_id query parameter, validates ownership via RLS, fetches positions with decrypted credentials</done>
</task>

<task type="auto">
  <name>Task 3: Add get_orders_with_credential method (for TRADE-04)</name>
  <files>apps/orchestrator_3_stream/backend/modules/alpaca_service.py</files>
  <action>
Add a method to fetch orders using provided credentials.

Check if there's an existing get_orders or similar method first. If so, create a credential-accepting variant. If not, create the method from scratch.

```python
async def get_orders_with_credential(
    self,
    api_key: str,
    secret_key: str,
    paper: bool = True,
    status: str = "all",
    limit: int = 100
) -> List[dict]:
    """
    Get orders using provided credentials.

    Args:
        api_key: Decrypted Alpaca API key
        secret_key: Decrypted Alpaca secret key
        paper: Whether to use paper trading endpoint
        status: Order status filter ('all', 'open', 'closed')
        limit: Maximum number of orders to return

    Returns:
        List of order dictionaries

    Raises:
        Exception: If API call fails
    """
    try:
        self.logger.info(f"Fetching orders with provided credentials, status={status}, limit={limit}")

        # Create temporary client with provided credentials
        temp_client = TradingClient(
            api_key=api_key,
            secret_key=secret_key,
            paper=paper
        )

        # Build request params
        from alpaca.trading.requests import GetOrdersRequest
        from alpaca.trading.enums import QueryOrderStatus

        status_enum = {
            "all": QueryOrderStatus.ALL,
            "open": QueryOrderStatus.OPEN,
            "closed": QueryOrderStatus.CLOSED
        }.get(status, QueryOrderStatus.ALL)

        request_params = GetOrdersRequest(
            status=status_enum,
            limit=limit
        )

        # Get orders from Alpaca
        orders = temp_client.get_orders(filter=request_params)

        # Convert to dict format for JSON serialization
        orders_list = []
        for order in orders:
            orders_list.append({
                "id": str(order.id),
                "symbol": order.symbol,
                "qty": str(order.qty) if order.qty else None,
                "filled_qty": str(order.filled_qty) if order.filled_qty else None,
                "side": order.side.value if order.side else None,
                "type": order.type.value if order.type else None,
                "status": order.status.value if order.status else None,
                "created_at": order.created_at.isoformat() if order.created_at else None,
                "filled_at": order.filled_at.isoformat() if order.filled_at else None,
                "filled_avg_price": str(order.filled_avg_price) if order.filled_avg_price else None,
            })

        self.logger.info(f"Fetched {len(orders_list)} orders with provided credentials")
        return orders_list

    except Exception as e:
        self.logger.error(f"Failed to get orders with provided credentials: {e}")
        raise
```

Note: Adjust the order serialization based on what fields the existing codebase uses. The goal is to have a method that accepts credentials and returns order data.
  </action>
  <verify>
Run: `cd /Users/muzz/Desktop/tac/TOD/apps/orchestrator_3_stream/backend && uv run python -c "from modules.alpaca_service import AlpacaService; print('get_orders_with_credential' in dir(AlpacaService))"`
Should print: True
  </verify>
  <done>AlpacaService has get_orders_with_credential method for fetching order history with provided credentials</done>
</task>

</tasks>

<verification>
Overall plan verification:
1. `grep "get_all_positions_with_credential" /Users/muzz/Desktop/tac/TOD/apps/orchestrator_3_stream/backend/modules/alpaca_service.py` - Should show new method
2. `grep "get_orders_with_credential" /Users/muzz/Desktop/tac/TOD/apps/orchestrator_3_stream/backend/modules/alpaca_service.py` - Should show orders method
3. `grep "credential_id.*Query" /Users/muzz/Desktop/tac/TOD/apps/orchestrator_3_stream/backend/main.py` - Should show credential_id as query param in positions endpoint
</verification>

<success_criteria>
- AlpacaService has get_all_positions_with_credential method
- AlpacaService has get_orders_with_credential method
- Positions endpoint requires credential_id query parameter
- Positions endpoint validates credential ownership via RLS
- Positions endpoint uses decrypt-on-demand pattern
</success_criteria>

<output>
After completion, create `.planning/phases/06-trading-context/06-02-SUMMARY.md`
</output>
