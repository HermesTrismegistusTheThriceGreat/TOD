---
phase: 06-trading-context
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/orchestrator_3_stream/backend/modules/alpaca_agent_models.py
  - apps/orchestrator_3_stream/backend/modules/alpaca_agent_service.py
  - apps/orchestrator_3_stream/backend/main.py
autonomous: true

must_haves:
  truths:
    - "Chat endpoint requires credential_id in request body"
    - "Chat endpoint validates credential ownership via RLS before execution"
    - "Decrypted credentials exist only during agent invocation scope"
  artifacts:
    - path: "apps/orchestrator_3_stream/backend/modules/alpaca_agent_models.py"
      provides: "AlpacaAgentChatRequest with credential_id field"
      contains: "credential_id"
    - path: "apps/orchestrator_3_stream/backend/modules/alpaca_agent_service.py"
      provides: "invoke_agent_streaming_with_credential method"
      contains: "invoke_agent_streaming_with_credential"
    - path: "apps/orchestrator_3_stream/backend/main.py"
      provides: "Chat endpoint using RLS + credential validation"
      contains: "get_decrypted_alpaca_credential"
  key_links:
    - from: "main.py alpaca_agent_chat"
      to: "get_connection_with_rls"
      via: "RLS context establishment"
      pattern: "get_connection_with_rls.*user"
    - from: "main.py alpaca_agent_chat"
      to: "get_decrypted_alpaca_credential"
      via: "credential decryption"
      pattern: "get_decrypted_alpaca_credential.*credential_id"
    - from: "alpaca_agent_service.py"
      to: "ClaudeSDKClient"
      via: "credential injection in mcp_servers env"
      pattern: "ALPACA_API_KEY.*api_key"
---

<objective>
Add credential context to chat endpoint so trades execute against user's selected account only.

Purpose: TRADE-01 and TRADE-02 require chat to use the explicitly selected credential, validated via RLS before any trade execution.
Output: Modified chat endpoint that requires credential_id, validates ownership, and passes credentials to agent invocation.
</objective>

<execution_context>
@/Users/muzz/.claude/get-shit-done/workflows/execute-plan.md
@/Users/muzz/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-trading-context/06-RESEARCH.md

# Key existing files
@apps/orchestrator_3_stream/backend/modules/alpaca_agent_models.py
@apps/orchestrator_3_stream/backend/modules/alpaca_agent_service.py
@apps/orchestrator_3_stream/backend/modules/credential_service.py
@apps/orchestrator_3_stream/backend/modules/database.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add credential_id to AlpacaAgentChatRequest</name>
  <files>apps/orchestrator_3_stream/backend/modules/alpaca_agent_models.py</files>
  <action>
Modify AlpacaAgentChatRequest to include credential_id field:

1. Add import for UUID at top: `from uuid import UUID`

2. Add credential_id field to AlpacaAgentChatRequest:
```python
credential_id: str = Field(
    ...,
    description="UUID of the credential to use for this trading operation"
)
```

3. Add field validator for credential_id (after the message validator):
```python
@field_validator('credential_id')
@classmethod
def validate_credential_id(cls, v: str) -> str:
    """Validate credential_id is a valid UUID."""
    try:
        UUID(v)
        return v
    except ValueError:
        raise ValueError("credential_id must be a valid UUID")
```

The field is required (no default) because every chat request MUST specify which credential to use. This prevents accidental use of global credentials.
  </action>
  <verify>
Run: `cd /Users/muzz/Desktop/tac/TOD/apps/orchestrator_3_stream/backend && uv run python -c "from modules.alpaca_agent_models import AlpacaAgentChatRequest; import json; r = AlpacaAgentChatRequest(message='test', credential_id='550e8400-e29b-41d4-a716-446655440000'); print(json.dumps(r.model_dump()))"`
Should print JSON with both message and credential_id fields.

Also verify validation rejects invalid UUID:
`cd /Users/muzz/Desktop/tac/TOD/apps/orchestrator_3_stream/backend && uv run python -c "from modules.alpaca_agent_models import AlpacaAgentChatRequest; AlpacaAgentChatRequest(message='test', credential_id='not-a-uuid')" 2>&1 | grep -q "credential_id must be a valid UUID" && echo "Validation works"`
  </verify>
  <done>AlpacaAgentChatRequest requires credential_id field, validates it's a valid UUID</done>
</task>

<task type="auto">
  <name>Task 2: Add invoke_agent_streaming_with_credential method</name>
  <files>apps/orchestrator_3_stream/backend/modules/alpaca_agent_service.py</files>
  <action>
Add a new method to AlpacaAgentService that accepts decrypted credentials as parameters:

1. Add new method `invoke_agent_streaming_with_credential` after the existing `invoke_agent_streaming` method:

```python
async def invoke_agent_streaming_with_credential(
    self,
    message: str,
    api_key: str,
    secret_key: str,
    paper_trade: bool = True
) -> AsyncGenerator[str, None]:
    """
    Invoke the Alpaca agent with streaming using provided credentials.

    This method is used when credentials come from encrypted storage
    rather than environment variables. Credentials should only exist
    in the calling scope and are passed directly here.

    Args:
        message: Natural language message/command for the agent
        api_key: Decrypted Alpaca API key
        secret_key: Decrypted Alpaca secret key
        paper_trade: Whether to use paper trading (default True)

    Yields:
        SSE-formatted string chunks
    """
    self.logger.info(f"[ALPACA AGENT SERVICE] Invoking agent (streaming) with provided credentials: {message[:100]}...")

    client = None

    try:
        # Build options with provided credentials (NOT from environment)
        env_vars = {}
        if "ANTHROPIC_API_KEY" in os.environ:
            env_vars["ANTHROPIC_API_KEY"] = os.environ["ANTHROPIC_API_KEY"]

        # Use provided credentials
        env_vars["ALPACA_API_KEY"] = api_key
        env_vars["ALPACA_SECRET_KEY"] = secret_key
        env_vars["ALPACA_PAPER_TRADE"] = "true" if paper_trade else "false"

        options_dict = {
            "system_prompt": ALPACA_AGENT_SYSTEM_PROMPT,
            "model": "sonnet",
            "cwd": str(self.working_dir),
            "env": env_vars,
            "mcp_servers": {
                "alpaca": {
                    "type": "stdio",
                    "command": "uvx",
                    "args": ["alpaca-mcp-server", "serve"],
                    "env": {
                        "ALPACA_API_KEY": api_key,
                        "ALPACA_SECRET_KEY": secret_key,
                        "ALPACA_PAPER_TRADE": "true" if paper_trade else "false",
                    }
                }
            },
        }

        # Add allowed tools (same as existing method)
        options_dict["allowed_tools"] = [
            "mcp__alpaca__get_account_info",
            "mcp__alpaca__get_all_positions",
            "mcp__alpaca__get_open_position",
            "mcp__alpaca__get_portfolio_history",
            "mcp__alpaca__close_position",
            "mcp__alpaca__close_all_positions",
            "mcp__alpaca__get_asset",
            "mcp__alpaca__get_all_assets",
            "mcp__alpaca__get_calendar",
            "mcp__alpaca__get_clock",
            "mcp__alpaca__get_corporate_actions",
            "mcp__alpaca__get_stock_bars",
            "mcp__alpaca__get_stock_quotes",
            "mcp__alpaca__get_stock_trades",
            "mcp__alpaca__get_stock_latest_bar",
            "mcp__alpaca__get_stock_latest_quote",
            "mcp__alpaca__get_stock_latest_trade",
            "mcp__alpaca__get_stock_snapshot",
            "mcp__alpaca__get_crypto_bars",
            "mcp__alpaca__get_crypto_quotes",
            "mcp__alpaca__get_crypto_trades",
            "mcp__alpaca__get_crypto_latest_bar",
            "mcp__alpaca__get_crypto_latest_quote",
            "mcp__alpaca__get_crypto_latest_trade",
            "mcp__alpaca__get_crypto_snapshot",
            "mcp__alpaca__get_crypto_latest_orderbook",
            "mcp__alpaca__get_option_contracts",
            "mcp__alpaca__get_option_latest_quote",
            "mcp__alpaca__get_option_snapshot",
            "mcp__alpaca__get_option_chain",
            "mcp__alpaca__place_option_market_order",
            "mcp__alpaca__exercise_options_position",
            "mcp__alpaca__place_stock_order",
            "mcp__alpaca__place_crypto_order",
            "mcp__alpaca__get_orders",
            "mcp__alpaca__cancel_order_by_id",
            "mcp__alpaca__cancel_all_orders",
            "mcp__alpaca__get_watchlists",
            "mcp__alpaca__get_watchlist_by_id",
            "mcp__alpaca__create_watchlist",
            "mcp__alpaca__update_watchlist_by_id",
            "mcp__alpaca__add_asset_to_watchlist_by_id",
            "mcp__alpaca__remove_asset_from_watchlist_by_id",
            "mcp__alpaca__delete_watchlist_by_id",
        ]

        options = ClaudeAgentOptions(**options_dict)
        self.logger.info(f"[ALPACA AGENT SERVICE] Working directory: {self.working_dir}")

        client = ClaudeSDKClient(options=options)
        await client.__aenter__()

        self.logger.info("[ALPACA AGENT SERVICE] Claude SDK client started with provided credentials")

        # Send user's prompt
        await client.query(message)

        # Stream responses (same logic as invoke_agent_streaming)
        chunk_count = 0

        async for msg in client.receive_response():
            if isinstance(msg, SystemMessage):
                subtype = getattr(msg, "subtype", "unknown")
                self.logger.debug(f"[ALPACA AGENT SERVICE] SystemMessage: {subtype}")
                continue

            if isinstance(msg, AssistantMessage):
                for block in msg.content:
                    if isinstance(block, TextBlock):
                        chunk_count += 1
                        chunk_data = {
                            "type": "text",
                            "content": block.text
                        }
                        yield f"data: {json.dumps(chunk_data)}\n\n"
                        self.logger.debug(f"Streamed text chunk {chunk_count}")

                    elif isinstance(block, ThinkingBlock):
                        chunk_data = {
                            "type": "thinking",
                            "content": block.thinking
                        }
                        yield f"data: {json.dumps(chunk_data)}\n\n"
                        self.logger.debug("Streamed thinking block")

                    elif isinstance(block, ToolUseBlock):
                        chunk_data = {
                            "type": "tool_use",
                            "tool_name": block.name,
                            "tool_input": block.input
                        }
                        yield f"data: {json.dumps(chunk_data)}\n\n"
                        self.logger.debug(f"Streamed tool use: {block.name}")

            elif isinstance(msg, ResultMessage):
                self.logger.info(
                    f"[ALPACA AGENT SERVICE] Completed: "
                    f"turns={getattr(msg, 'num_turns', 'N/A')}, "
                    f"cost=${getattr(msg, 'total_cost_usd', 0.0):.4f}"
                )

        self.logger.success(f"[ALPACA AGENT SERVICE] Streaming completed with provided credentials, chunks={chunk_count}")
        yield "data: [DONE]\n\n"

    except asyncio.CancelledError:
        self.logger.warning("Alpaca agent streaming cancelled by client")
        cancel_chunk = {"type": "error", "content": "Stream cancelled"}
        yield f"data: {json.dumps(cancel_chunk)}\n\n"
        yield "data: [DONE]\n\n"

    except Exception as e:
        self.logger.error(f"Failed to stream Alpaca agent response: {e}", exc_info=True)
        error_chunk = {"type": "error", "content": f"Streaming error: {str(e)}"}
        yield f"data: {json.dumps(error_chunk)}\n\n"
        yield "data: [DONE]\n\n"

    finally:
        if client:
            try:
                await client.__aexit__(None, None, None)
            except Exception as e:
                self.logger.warning(f"Error closing client: {e}")
```

Note: This method does NOT call verify_mcp_config() because credentials are provided, not loaded from environment.
  </action>
  <verify>
Run: `cd /Users/muzz/Desktop/tac/TOD/apps/orchestrator_3_stream/backend && uv run python -c "from modules.alpaca_agent_service import AlpacaAgentService; import inspect; print('invoke_agent_streaming_with_credential' in dir(AlpacaAgentService))"`
Should print: True
  </verify>
  <done>AlpacaAgentService has invoke_agent_streaming_with_credential method that accepts api_key and secret_key parameters</done>
</task>

<task type="auto">
  <name>Task 3: Modify chat endpoint to validate credential and use RLS</name>
  <files>apps/orchestrator_3_stream/backend/main.py</files>
  <action>
Modify the `/api/alpaca-agent/chat` endpoint to:
1. Accept credential_id from request body
2. Validate credential ownership via RLS
3. Decrypt credentials on-demand
4. Use the new invoke_agent_streaming_with_credential method

Find the existing `alpaca_agent_chat` function (around line 1573) and replace it:

1. Add required imports at the top of main.py (near other imports):
```python
from modules.database import get_connection_with_rls
from modules.credential_service import get_decrypted_alpaca_credential
```

2. Replace the alpaca_agent_chat function:

```python
@app.post("/api/alpaca-agent/chat", tags=["Alpaca Agent"])
async def alpaca_agent_chat(request: Request, chat_request: AlpacaAgentChatRequest):
    """
    Chat with the Alpaca trading agent using natural language.

    Validates credential ownership via RLS, decrypts credentials on-demand,
    and streams the agent response back using Server-Sent Events (SSE).

    Args:
        chat_request: Request with user message and credential_id

    Returns:
        StreamingResponse with SSE chunks

    Raises:
        403: If credential not found or not owned by user
        503: If Alpaca Agent service not initialized
    """
    try:
        logger.http_request("POST", "/api/alpaca-agent/chat")
        logger.info(f"[ALPACA AGENT] Received chat request with credential_id: {chat_request.credential_id}")

        # Check if service is available
        if not hasattr(request.app.state, 'alpaca_agent_service') or request.app.state.alpaca_agent_service is None:
            logger.error("[ALPACA AGENT] Service not initialized")
            return JSONResponse(
                status_code=503,
                content={
                    "status": "error",
                    "error": "Alpaca Agent service not initialized. Backend may still be starting up."
                }
            )

        alpaca_agent_service: AlpacaAgentService = request.app.state.alpaca_agent_service

        # Check if Claude SDK is available
        if not alpaca_agent_service.claude_path:
            logger.error("[ALPACA AGENT] Claude SDK not available")
            return JSONResponse(
                status_code=503,
                content={
                    "status": "error",
                    "error": "Claude Agent SDK not available. Check that claude-agent-sdk is installed."
                }
            )

        # For now, use a placeholder user_id until auth integration
        # TODO: Replace with actual user from auth middleware: user = Depends(get_current_user)
        # This is a temporary approach - in production, get user_id from auth
        user_id = request.headers.get("X-User-ID", "demo-user")

        logger.info(f"[ALPACA AGENT] Validating credential ownership for user: {user_id}")

        # Validate credential ownership via RLS and get decrypted credentials
        try:
            async with get_connection_with_rls(user_id) as conn:
                async with get_decrypted_alpaca_credential(
                    conn, chat_request.credential_id, user_id
                ) as (api_key, secret_key):
                    # Credentials validated and decrypted - they exist only in this scope
                    logger.info("[ALPACA AGENT] Credential validated, starting streaming response")

                    # Determine if paper trading based on credential
                    # For now default to True, could be stored in credential metadata
                    paper_trade = True

                    # Stream response using SSE with provided credentials
                    async def generate_sse():
                        try:
                            logger.debug("[ALPACA AGENT] Starting SSE generator with credential context")
                            chunk_count = 0
                            async for chunk in alpaca_agent_service.invoke_agent_streaming_with_credential(
                                chat_request.message,
                                api_key=api_key,
                                secret_key=secret_key,
                                paper_trade=paper_trade
                            ):
                                chunk_count += 1
                                yield chunk
                            logger.info(f"[ALPACA AGENT] SSE streaming complete, chunks={chunk_count}")
                        except Exception as e:
                            logger.error(f"[ALPACA AGENT] Streaming error: {e}", exc_info=True)
                            error_chunk = json.dumps({"type": "error", "content": str(e)})
                            yield f"data: {error_chunk}\n\n"
                            yield "data: [DONE]\n\n"

                    logger.http_request("POST", "/api/alpaca-agent/chat", 200)
                    return StreamingResponse(
                        generate_sse(),
                        media_type="text/event-stream",
                        headers={
                            "Cache-Control": "no-cache",
                            "Connection": "keep-alive",
                            "X-Accel-Buffering": "no"
                        }
                    )

        except ValueError as e:
            # Credential not found or not owned by user (RLS rejection)
            logger.error(f"[ALPACA AGENT] Credential validation failed: {e}")
            return JSONResponse(
                status_code=403,
                content={
                    "status": "error",
                    "error": f"Credential access denied: {str(e)}"
                }
            )

    except Exception as e:
        logger.error(f"[ALPACA AGENT] Chat endpoint failed: {e}", exc_info=True)
        return JSONResponse(
            status_code=500,
            content={
                "status": "error",
                "error": str(e)
            }
        )
```

Note: The endpoint uses X-User-ID header as a temporary auth mechanism. This should be replaced with proper auth middleware (Depends(get_current_user)) when fully integrated.
  </action>
  <verify>
Check imports are present:
`grep -q "from modules.database import get_connection_with_rls" /Users/muzz/Desktop/tac/TOD/apps/orchestrator_3_stream/backend/main.py && echo "database import OK"`
`grep -q "from modules.credential_service import get_decrypted_alpaca_credential" /Users/muzz/Desktop/tac/TOD/apps/orchestrator_3_stream/backend/main.py && echo "credential_service import OK"`

Check endpoint uses credential validation:
`grep -q "get_decrypted_alpaca_credential" /Users/muzz/Desktop/tac/TOD/apps/orchestrator_3_stream/backend/main.py && echo "Uses credential decryption"`
`grep -q "get_connection_with_rls" /Users/muzz/Desktop/tac/TOD/apps/orchestrator_3_stream/backend/main.py && echo "Uses RLS context"`
  </verify>
  <done>Chat endpoint requires credential_id, validates ownership via RLS, decrypts on-demand, uses credentials only within scoped context</done>
</task>

</tasks>

<verification>
Overall plan verification:
1. `grep "credential_id" /Users/muzz/Desktop/tac/TOD/apps/orchestrator_3_stream/backend/modules/alpaca_agent_models.py` - Should show credential_id field
2. `grep "invoke_agent_streaming_with_credential" /Users/muzz/Desktop/tac/TOD/apps/orchestrator_3_stream/backend/modules/alpaca_agent_service.py` - Should show new method
3. `grep -A5 "get_decrypted_alpaca_credential" /Users/muzz/Desktop/tac/TOD/apps/orchestrator_3_stream/backend/main.py` - Should show RLS context usage in chat endpoint
</verification>

<success_criteria>
- AlpacaAgentChatRequest has required credential_id field with UUID validation
- AlpacaAgentService has invoke_agent_streaming_with_credential method
- Chat endpoint validates credential ownership via RLS before execution
- Chat endpoint uses decrypt-on-demand pattern (credentials only in scoped context)
- Chat endpoint returns 403 when credential not found or not owned
</success_criteria>

<output>
After completion, create `.planning/phases/06-trading-context/06-01-SUMMARY.md`
</output>
