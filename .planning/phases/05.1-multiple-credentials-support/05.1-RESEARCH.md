# Phase 5.1: Multiple Credentials Support - Research

**Researched:** 2026-01-31
**Domain:** Database schema modification, PostgreSQL unique constraints, multi-credential UI patterns
**Confidence:** HIGH

## Summary

Phase 5.1 addresses the 409 Conflict error when users attempt to add multiple Alpaca credentials (e.g., paper1, paper2, live) to the same account. The root cause is a unique constraint `idx_user_credentials_unique ON user_credentials(user_account_id, credential_type)` that prevents multiple credentials of the same type per account.

The standard approach combines three elements: (1) removing or modifying the unique constraint, (2) adding a user-friendly label/nickname field for credential distinction, and (3) implementing a credential selector UI. This is a well-established pattern in multi-tenant credential management systems.

Current state analysis reveals:
- Database has 3 test credentials available (.env): PAPER1, PAPER2, LIVE
- All use `credential_type = "alpaca"` causing constraint violation on second insert
- Backend uses `credential_type` to determine paper vs live routing (Phase 5 decision)
- Frontend has `activeCredentialId` in accountStore for switching credentials
- Tests use `alpaca_paper` credential_type but production code uses `alpaca`

**Primary recommendation:** Drop the unique constraint, add a `nickname` VARCHAR(255) field for user labels, and extend the frontend selector to handle multiple credentials per type.

## Standard Stack

### Core
| Library | Version | Purpose | Why Standard |
|---------|---------|---------|--------------|
| PostgreSQL | 14+ | Database with DDL migration | Industry standard for transactional data with excellent constraint management |
| asyncpg | latest | Async PostgreSQL driver | Used throughout existing codebase for database access |
| Pydantic | 2.x | Data validation | Already used for all API schemas and database models |
| Vue 3 | latest | Frontend framework | Existing frontend stack for account management UI |

### Supporting
| Library | Version | Purpose | When to Use |
|---------|---------|---------|-------------|
| Fernet (cryptography) | latest | Credential encryption | Already in use for encrypting api_key/secret_key fields |

### Alternatives Considered
| Instead of | Could Use | Tradeoff |
|------------|-----------|----------|
| Nickname field | Composite credential_type (alpaca_paper1, alpaca_paper2) | Harder to query, forces type proliferation, poor UX |
| Drop constraint | Partial unique index on (account_id, type, nickname) | Adds complexity, nickname must be unique per type |

**Installation:**
No new dependencies required. All changes use existing stack.

## Architecture Patterns

### Recommended Project Structure
```
apps/orchestrator_db/migrations/
├── 15_multiple_credentials_support.sql  # DROP constraint, ADD nickname column

apps/orchestrator_3_stream/backend/
├── schemas/credential_schemas.py         # Add nickname field to requests/responses
├── modules/credential_service.py         # Update store_credential to accept nickname
└── routers/credentials.py                # No changes needed (uses service layer)

apps/orchestrator_3_stream/frontend/src/
├── types/account.ts                      # Add nickname to CredentialResponse
├── stores/accountStore.ts                # No major changes (already handles multiple)
└── components/
    ├── CredentialSelector.vue            # Update to show nicknames, group by type
    └── AddCredentialDialog.vue           # Add nickname input field
```

### Pattern 1: Database Migration - Constraint Removal + Column Addition

**What:** Single migration that drops the unique constraint and adds nickname column with backward compatibility.

**When to use:** When relaxing uniqueness requirements and adding distinguishing metadata simultaneously.

**Example:**
```sql
-- Migration 15: Support multiple credentials per account
-- Drops unique constraint and adds nickname field

-- Drop the unique constraint that prevents multiple credentials per type
DROP INDEX IF EXISTS idx_user_credentials_unique;

-- Add nickname field for user-friendly credential labels
ALTER TABLE user_credentials
ADD COLUMN IF NOT EXISTS nickname VARCHAR(255);

-- Add comment
COMMENT ON COLUMN user_credentials.nickname IS
'User-provided label to distinguish multiple credentials (e.g., "Paper Trading Account 1", "Live Trading")';

-- Optional: Add index on nickname for faster searches
CREATE INDEX IF NOT EXISTS idx_user_credentials_nickname
ON user_credentials(user_account_id, nickname);
```

**Source:** [PostgreSQL Unique Constraints](https://www.postgresql.org/docs/current/ddl-constraints.html), [How to DROP UNIQUE CONSTRAINT in PostgreSQL](https://www.commandprompt.com/education/how-to-drop-unique-constraint-in-postgresql/)

### Pattern 2: Service Layer Update - Nickname Parameter

**What:** Add optional nickname parameter to credential storage function with sensible defaults.

**When to use:** When extending existing service functions with backward-compatible parameters.

**Example:**
```python
async def store_credential(
    conn,
    account_id: UUID,
    user_id: str,
    credential_type: str,
    api_key: str,
    secret_key: str,
    nickname: Optional[str] = None,  # NEW: optional user label
) -> UUID:
    """
    Store encrypted credential in database.

    Args:
        nickname: Optional user-friendly label (e.g., "Paper Account 1")
                  Defaults to credential_type if not provided
    """
    # Default nickname to credential_type for backward compatibility
    if nickname is None:
        nickname = credential_type

    # ... rest of existing logic ...

    await conn.execute(
        """
        INSERT INTO user_credentials (
            id, user_account_id, user_id, credential_type,
            api_key, secret_key, nickname, is_active, created_at, updated_at
        ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, NOW(), NOW())
        """,
        credential_id,
        account_id,
        user_id,
        credential_type,
        encrypted_api_key,
        encrypted_secret_key,
        nickname,  # NEW
        True,
    )
```

### Pattern 3: Frontend Credential Selector - Grouped Display

**What:** Update credential selector to group by type and display nicknames for disambiguation.

**When to use:** When users need to select from multiple credentials of the same provider/type.

**Example (Vue 3 Composition API):**
```typescript
// Computed property: group credentials by type
const credentialsByType = computed(() => {
  const groups: Record<string, CredentialResponse[]> = {}

  credentials.value.forEach(cred => {
    if (!groups[cred.credential_type]) {
      groups[cred.credential_type] = []
    }
    groups[cred.credential_type].push(cred)
  })

  return groups
})

// Display label: nickname or fallback to type
function getCredentialLabel(cred: CredentialResponse): string {
  return cred.nickname || cred.credential_type || 'Unnamed Credential'
}
```

```vue
<!-- Template: dropdown with grouped options -->
<select v-model="activeCredentialId" @change="handleCredentialChange">
  <optgroup
    v-for="(creds, type) in credentialsByType"
    :key="type"
    :label="type"
  >
    <option
      v-for="cred in creds"
      :key="cred.id"
      :value="cred.id"
    >
      {{ getCredentialLabel(cred) }}
    </option>
  </optgroup>
</select>
```

**Source:** [Best Practices for Designing a User Authentication Module](https://vertabelo.com/blog/user-authentication-module/), [Vue Select Component](https://vue-select.org/)

### Anti-Patterns to Avoid

- **Encoding distinctions in credential_type:** Don't create `alpaca_paper1`, `alpaca_paper2`, `alpaca_live` as separate types. This forces type proliferation and breaks the single-source-of-truth principle. Use a dedicated `nickname` field instead.

- **Allowing NULL nicknames without defaults:** If nickname is optional, always provide a sensible default (e.g., credential_type) to avoid empty labels in UI.

- **Client-side credential validation only:** Always validate uniqueness and required fields on backend. Frontend validation is UX, not security.

- **Modifying existing credentials without user confirmation:** When adding nickname field to existing rows, use UPDATE with default values rather than requiring user input for legacy credentials.

## Don't Hand-Roll

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| Credential grouping UI | Custom dropdown with manual grouping | `<optgroup>` in HTML5 or Vue Select | Browser-native, accessible, well-tested |
| Database migration rollback | Manual rollback scripts | PostgreSQL transactions + IF EXISTS guards | Idempotent migrations prevent errors on retry |
| Nickname uniqueness validation | Application-level checks before insert | Database constraint or accept duplicates | Avoid race conditions, simpler logic |

**Key insight:** Database schema changes should be backward-compatible when possible. Adding nullable columns and dropping constraints are safer than adding constraints or making columns NOT NULL.

## Common Pitfalls

### Pitfall 1: Forgetting to Update Pydantic Models

**What goes wrong:** Database schema changes but Pydantic models in `models.py` remain stale, causing asyncpg serialization errors or missing fields in API responses.

**Why it happens:** Project has separate `migrations/` and `models.py` files that must be kept in sync manually (documented in CLAUDE.md).

**How to avoid:**
1. Update `apps/orchestrator_db/models.py` immediately after writing migration SQL
2. Add `nickname: Optional[str]` to `UserCredentialORM` class
3. Run test suite to verify serialization works

**Warning signs:**
- `TypeError: __init__() got an unexpected keyword argument 'nickname'`
- Missing field in API responses despite database having the column

### Pitfall 2: Breaking Existing Tests with Constraint Removal

**What goes wrong:** Tests that expect 409 Conflict on duplicate credential_type now pass when they should fail (or need updating).

**Why it happens:** Test file `test_credential_endpoints.py` has test cases validating the unique constraint behavior.

**How to avoid:**
1. Identify tests checking for UniqueViolationError or 409 status
2. Update or remove these tests since multiple credentials per type is now allowed
3. Add NEW tests verifying multiple credentials can be added successfully

**Warning signs:**
- Tests pass locally but behavior is wrong (no longer prevents duplicates)
- Integration tests fail with "expected 409 but got 201"

### Pitfall 3: Frontend Credential Selector Shows Duplicate Labels

**What goes wrong:** User adds two "alpaca" credentials without nicknames, both show as "alpaca" in dropdown, impossible to distinguish.

**Why it happens:** Frontend displays credential_type when nickname is null/empty.

**How to avoid:**
1. Backend defaults nickname to credential_type if not provided
2. Frontend fallback: `nickname || credential_type || 'Unnamed'`
3. Better: Make nickname required in UI (optional in database for backward compatibility)

**Warning signs:**
- User feedback: "I can't tell which account is which"
- Multiple identical labels in credential selector dropdown

### Pitfall 4: Existing Credentials Missing Nickname After Migration

**What goes wrong:** Migration adds `nickname` column but leaves existing rows with NULL, causing UI to show empty labels.

**Why it happens:** `ALTER TABLE ADD COLUMN` defaults to NULL for existing rows unless DEFAULT is specified.

**How to avoid:**
```sql
-- Option 1: Add column with default
ALTER TABLE user_credentials
ADD COLUMN nickname VARCHAR(255) DEFAULT 'alpaca';

-- Option 2: Add column then backfill
ALTER TABLE user_credentials ADD COLUMN nickname VARCHAR(255);
UPDATE user_credentials SET nickname = credential_type WHERE nickname IS NULL;
```

**Warning signs:**
- Newly added credentials show nicknames, but old credentials show blank
- Users report some accounts are "unnamed" in dropdown

## Code Examples

Verified patterns from existing codebase and official PostgreSQL documentation:

### Example 1: Complete Migration File

```sql
-- ============================================================================
-- MIGRATION 15: Multiple Credentials Support
-- ============================================================================
-- Allows users to add multiple credentials of the same type per account.
-- Adds nickname field for user-friendly credential labels.
--
-- Dependencies:
-- - Migration 14: user_accounts and user_credentials tables must exist
--
-- Breaking Changes:
-- - Drops unique constraint on (user_account_id, credential_type)
-- - Users can now have multiple "alpaca" credentials per account
-- ============================================================================

-- Drop unique constraint preventing multiple credentials per type
-- This was originally added in Migration 14 (02-01-PLAN.md decision)
-- Now removing to support use case: multiple paper accounts, multiple live accounts
DROP INDEX IF EXISTS idx_user_credentials_unique;

-- Add nickname field for user-provided labels
-- Examples: "Paper Trading Account 1", "Live Trading - Strategy A"
-- Nullable for backward compatibility with existing credentials
ALTER TABLE user_credentials
ADD COLUMN IF NOT EXISTS nickname VARCHAR(255);

-- Backfill existing credentials with credential_type as nickname
-- Ensures all credentials have a display label in UI
UPDATE user_credentials
SET nickname = credential_type
WHERE nickname IS NULL;

-- Add index for faster lookups when filtering by nickname
CREATE INDEX IF NOT EXISTS idx_user_credentials_nickname
ON user_credentials(user_account_id, nickname);

-- Update column comment
COMMENT ON COLUMN user_credentials.nickname IS
'User-provided label to distinguish multiple credentials of same type (e.g., "Paper Account 1", "Live Trading")';
```

**Source:** Existing migration pattern from `apps/orchestrator_db/migrations/14_user_accounts.sql`

### Example 2: Update Pydantic Schema with Nickname

```python
# apps/orchestrator_3_stream/backend/schemas/credential_schemas.py

class StoreCredentialRequest(BaseModel):
    """Request to store a new credential."""

    account_id: str = Field(
        ...,
        description="UUID of the user account (user_accounts.id)"
    )
    credential_type: str = Field(
        ...,
        description="Type of credential: 'alpaca' or 'polygon'"
    )
    api_key: SecretStr = Field(
        ...,
        description="API key (masked in logs and errors)"
    )
    secret_key: SecretStr = Field(
        ...,
        description="Secret key (masked in logs and errors)"
    )
    nickname: Optional[str] = Field(  # NEW FIELD
        None,
        description="User-friendly label (e.g., 'Paper Account 1'). Defaults to credential_type if not provided."
    )


class CredentialResponse(BaseModel):
    """Response containing credential metadata (no plaintext credentials)."""

    model_config = ConfigDict(from_attributes=True)

    id: str = Field(..., description="Credential ID (UUID)")
    account_id: str = Field(..., description="User account ID (UUID)")
    credential_type: str = Field(..., description="Credential type (alpaca/polygon)")
    nickname: Optional[str] = Field(None, description="User-friendly label")  # NEW FIELD
    is_active: bool = Field(..., description="Whether credential is active")
    created_at: str = Field(..., description="Creation timestamp (ISO 8601)")
    updated_at: str = Field(..., description="Last update timestamp (ISO 8601)")
```

**Source:** Existing pattern from `apps/orchestrator_3_stream/backend/schemas/credential_schemas.py`

### Example 3: Frontend TypeScript Type Update

```typescript
// apps/orchestrator_3_stream/frontend/src/types/account.ts

export interface CredentialResponse {
  id: string
  account_id: string
  credential_type: string
  nickname?: string | null  // NEW FIELD - optional for backward compatibility
  is_active: boolean
  created_at: string
  updated_at: string
}

export interface CredentialInput {
  credential_type: string
  api_key: string
  secret_key: string
  nickname?: string  // NEW FIELD - optional, backend will default
}

// Helper: Get display label for credential
export function getCredentialDisplayLabel(cred: CredentialResponse): string {
  return cred.nickname || cred.credential_type || 'Unnamed Credential'
}
```

### Example 4: Backend Service Layer Update

```python
# apps/orchestrator_3_stream/backend/modules/credential_service.py

async def store_credential(
    conn,
    account_id: UUID,
    user_id: str,
    credential_type: str,
    api_key: str,
    secret_key: str,
    nickname: Optional[str] = None,  # NEW PARAMETER
) -> UUID:
    """
    Store encrypted credential in database.

    Args:
        conn: asyncpg connection (from get_connection_with_rls)
        account_id: UUID of user account (user_accounts.id)
        user_id: User ID (denormalized for RLS)
        credential_type: Credential type ("alpaca" or "polygon")
        api_key: Plaintext API key (will be encrypted)
        secret_key: Plaintext secret key (will be encrypted)
        nickname: Optional user-friendly label (defaults to credential_type)

    Returns:
        UUID: ID of created credential
    """
    # ... existing validation logic ...

    # Default nickname to credential_type if not provided
    if nickname is None or nickname.strip() == "":
        nickname = credential_type

    # ... existing encryption logic ...

    # Insert credential with encrypted values AND nickname
    await conn.execute(
        """
        INSERT INTO user_credentials (
            id, user_account_id, user_id, credential_type,
            api_key, secret_key, nickname, is_active, created_at, updated_at
        ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, NOW(), NOW())
        """,
        credential_id,
        account_id,
        user_id,
        credential_type,
        encrypted_api_key,
        encrypted_secret_key,
        nickname,  # NEW
        True,
    )

    logger.info(
        f"Credential stored: id={credential_id}, account_id={account_id}, "
        f"type={credential_type}, nickname={nickname}"
    )

    return credential_id
```

**Source:** Existing pattern from `apps/orchestrator_3_stream/backend/modules/credential_service.py`

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| Single credential per type via UNIQUE constraint | Multiple credentials per type with nickname labels | Phase 5.1 (2026-01-31) | Users can now add multiple paper/live accounts |
| credential_type as only identifier | credential_type + nickname for display | Phase 5.1 | Better UX, clearer account distinction |
| Hard error on duplicate type | Allow duplicates, rely on nickname for distinction | Phase 5.1 | More flexible, matches user mental model |

**Deprecated/outdated:**
- Unique constraint on `(user_account_id, credential_type)`: Removed in Migration 15, now allows multiple credentials per type
- Tests expecting 409 Conflict on duplicate credential_type: Need updating to reflect new behavior

## Open Questions

Things that couldn't be fully resolved:

1. **Should nickname be UNIQUE per (account_id, credential_type)?**
   - What we know: Current design allows duplicate nicknames (e.g., two credentials both named "Trading Account")
   - What's unclear: Whether this is acceptable UX or if we should enforce uniqueness
   - Recommendation: Start without uniqueness constraint, add if user feedback indicates confusion. Easier to add constraint later than remove it.

2. **Should we auto-migrate existing credentials to have better default nicknames?**
   - What we know: Migration backfills with `credential_type`, so existing credentials show "alpaca" as nickname
   - What's unclear: Should we derive better defaults from API key prefix (PK = paper, AK/CK = live)?
   - Recommendation: Use simple backfill (credential_type) for now. Users can edit nicknames manually. Auto-detection risks incorrect labels.

3. **How to handle credential selection when activeCredentialId is from deleted credential?**
   - What we know: accountStore already handles this by clearing activeCredentialId and localStorage
   - What's unclear: Should we auto-select first available credential or leave unselected?
   - Recommendation: Auto-select first active credential (existing behavior in accountStore.initialize). No changes needed.

## Sources

### Primary (HIGH confidence)

- **PostgreSQL Official Documentation**: [DDL Constraints](https://www.postgresql.org/docs/current/ddl-constraints.html) - Unique constraint behavior and modification
- **PostgreSQL Official Documentation**: [ALTER TABLE](https://www.postgresql.org/docs/7.2/sql-altertable.html) - Column addition syntax
- **CommandPrompt.com**: [How to DROP UNIQUE CONSTRAINT in PostgreSQL](https://www.commandprompt.com/education/how-to-drop-unique-constraint-in-postgresql/) - Migration pattern for constraint removal
- **Existing codebase**:
  - `apps/orchestrator_db/migrations/14_user_accounts.sql` - Current schema and constraint definition
  - `apps/orchestrator_3_stream/backend/modules/credential_service.py` - Credential storage pattern
  - `apps/orchestrator_3_stream/frontend/src/stores/accountStore.ts` - Credential selection logic
  - `.env` file - Test credentials confirming PAPER1, PAPER2, LIVE accounts available

### Secondary (MEDIUM confidence)

- **Vertabelo**: [Best Practices for Designing a User Authentication Module](https://vertabelo.com/blog/user-authentication-module/) - Multi-credential patterns and account merging
- **Redgate**: [Merging Multiple User Accounts](https://www.red-gate.com/blog/how-to-store-authentication-data-in-a-database-part-5-merging-multiple-user-accounts) - Multiple login credentials per account architecture
- **Vue Select**: [VueJS Select2/Chosen Component](https://vue-select.org/) - Dropdown component patterns (already using native select in codebase)

### Tertiary (LOW confidence)

- None - all findings verified with official documentation or existing codebase

## Metadata

**Confidence breakdown:**
- Standard stack: HIGH - Using existing PostgreSQL, asyncpg, Pydantic, Vue 3 stack. No new dependencies.
- Architecture: HIGH - Patterns derived from existing codebase migrations and service layer. PostgreSQL constraint modification is well-documented.
- Pitfalls: HIGH - Identified from codebase structure (models.py sync requirement, test updates) and common database migration issues.

**Research date:** 2026-01-31
**Valid until:** 2026-03-31 (60 days - stable domain, unlikely to change)

**Key decisions locked in:**
- [02-01-PLAN] Original unique constraint was intentional design decision, now being revised based on user feedback
- [03-01-PLAN] Backend determines paper vs live from credential_type stored in database (still valid, unchanged by this phase)
- [04-02-PLAN] activeCredentialId persisted to localStorage (unchanged, already supports multiple credentials)
- [05-01-PLAN] credential_type from database determines routing (unchanged, nickname is additional metadata only)

**Breaking changes introduced:**
- Unique constraint `idx_user_credentials_unique` removed - existing code expecting 409 Conflict will need updates
- Tests validating UniqueViolationError behavior must be updated or removed
- API schemas gain new optional `nickname` field (backward compatible via Optional type)
