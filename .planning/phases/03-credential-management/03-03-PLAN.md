---
phase: 03-credential-management
plan: 03
type: execute
wave: 3
depends_on: ["03-01", "03-02"]
files_modified:
  - apps/orchestrator_3_stream/backend/modules/alpaca_agent_service.py
  - apps/orchestrator_3_stream/backend/tests/test_credential_endpoints.py
  - apps/orchestrator_3_stream/backend/tests/test_credential_lifecycle.py
  - apps/orchestrator_3_stream/backend/tests/test_real_alpaca_integration.py
autonomous: true

must_haves:
  truths:
    - "Alpaca agent service can retrieve decrypted credentials on-demand for API calls"
    - "Plaintext credentials are never stored in session state or cached"
    - "Credential endpoints pass integration tests with real encrypted data"
    - "Credential validation against Alpaca API works end-to-end with REAL Alpaca paper credentials"
    - "Validation response includes account_status='ACTIVE' for fully operational accounts"
    - "Invalid credentials return is_valid=False with error message (graceful handling)"
    - "RLS isolation prevents users from accessing other users' credentials"
    - "API calls use appropriate timeouts (10s) to prevent test hangs"
  artifacts:
    - path: "apps/orchestrator_3_stream/backend/modules/alpaca_agent_service.py"
      provides: "Integration with credential service for on-demand decryption"
      contains: "get_decrypted_alpaca_credential"
    - path: "apps/orchestrator_3_stream/backend/tests/test_credential_endpoints.py"
      provides: "Integration tests for credential API endpoints"
      min_lines: 100
    - path: "apps/orchestrator_3_stream/backend/tests/test_credential_lifecycle.py"
      provides: "Tests for decrypt-on-demand pattern"
      min_lines: 80
    - path: "apps/orchestrator_3_stream/backend/tests/test_real_alpaca_integration.py"
      provides: "Real Alpaca API integration tests (no mocks)"
      min_lines: 100
  key_links:
    - from: "alpaca_agent_service.py"
      to: "credential_service.py"
      via: "uses get_decrypted_alpaca_credential context manager"
      pattern: "get_decrypted_alpaca_credential"
    - from: "test_credential_endpoints.py"
      to: "routers/credentials.py"
      via: "tests all credential endpoints"
      pattern: "TestClient|/api/credentials"
    - from: "test_real_alpaca_integration.py"
      to: "credential_service.py"
      via: "real Alpaca API validation"
      pattern: "ALPACA_API_KEY|validate_alpaca_credentials"

# Real Credential Test Configuration
# ⚠️  IMPORTANT: The root .env has DUPLICATE keys (ALPACA_API_KEY appears 3x).
#     python-dotenv loads the LAST value, which is the LIVE account.
#     Tests MUST use unique env var names to avoid this issue.
#
# Use these UNIQUE env var names for testing (add to .env):
#   - ALPACA_PAPER1_API_KEY: PK3VNBKEIVBKWNOA3O2QBHTYED
#   - ALPACA_PAPER1_SECRET_KEY: AfwcUtD1TAB62JPdYxq5ZuyyKvjXRkzjnCt7D23H3iUA
#   - Associated with user: seagerjoe@gmail.com
#   - Paper endpoint: https://paper-api.alpaca.markets
#
# For isolation test: creates temporary test user in database
---

<objective>
Integrate decrypt-on-demand into Alpaca agent service and create comprehensive test suite.

Purpose: Complete the credential management feature with Alpaca integration and verify all success criteria.
Output: Updated alpaca_agent_service.py, test_credential_endpoints.py, test_credential_lifecycle.py.
</objective>

<execution_context>
@/Users/muzz/.claude/get-shit-done/workflows/execute-plan.md
@/Users/muzz/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-credential-management/03-RESEARCH.md
@.planning/phases/03-credential-management/03-01-SUMMARY.md
@.planning/phases/03-credential-management/03-02-SUMMARY.md
@apps/orchestrator_3_stream/backend/modules/alpaca_agent_service.py
@apps/orchestrator_3_stream/backend/tests/test_user_credentials.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add credential retrieval to alpaca_agent_service.py</name>
  <files>apps/orchestrator_3_stream/backend/modules/alpaca_agent_service.py</files>
  <action>
Add method to AlpacaAgentService for credential-aware API invocation:

1. **invoke_with_stored_credential** async method:
   - Parameters: credential_id (str), user_id (str), operation (str), params (dict)
   - Uses get_decrypted_alpaca_credential context manager
   - Creates Alpaca client with plaintext credentials INSIDE the context
   - Executes the operation
   - Returns result
   - Plaintext discarded when context exits (context manager ensures this)

2. Add import at top:
   ```python
   from modules.credential_service import get_decrypted_alpaca_credential
   from modules.database import get_connection_with_rls
   ```

3. The method should:
   - Get database connection with RLS context
   - Use async context manager for credential decryption
   - Create temporary Alpaca client
   - Execute operation
   - Return result
   - Ensure plaintext is never stored as instance attribute

Example usage pattern (document in docstring):
```python
async with get_connection_with_rls(user_id) as conn:
    async with get_decrypted_alpaca_credential(conn, credential_id, user_id) as (api_key, secret_key):
        # Create client and execute - plaintext exists only here
        client = AlpacaClient(api_key=api_key, secret_key=secret_key)
        result = await client.get_account()
    # Plaintext discarded here
return result
```

Do NOT modify existing methods - only add new ones.
  </action>
  <verify>
```bash
cd apps/orchestrator_3_stream/backend && uv run python -c "
from modules.alpaca_agent_service import AlpacaAgentService
import inspect

# Verify class exists
assert AlpacaAgentService is not None

# Check for new method
service = AlpacaAgentService(logger=None, working_dir='/tmp')
assert hasattr(service, 'invoke_with_stored_credential'), 'Should have invoke_with_stored_credential method'
assert inspect.iscoroutinefunction(service.invoke_with_stored_credential), 'Should be async method'

print('OK - AlpacaAgentService updated with credential retrieval')
"
```
  </verify>
  <done>AlpacaAgentService has invoke_with_stored_credential method that uses decrypt-on-demand pattern</done>
</task>

<task type="auto">
  <name>Task 2: Create credential endpoint integration tests</name>
  <files>apps/orchestrator_3_stream/backend/tests/test_credential_endpoints.py</files>
  <action>
Create comprehensive test file for credential API endpoints:

1. **Test fixtures**:
   - test_client: FastAPI TestClient with app
   - mock_user: Mock authenticated user for get_current_user dependency
   - test_encryption_key: Set ENCRYPTION_KEY env var using monkeypatch

2. **Test cases for POST /api/credentials/store**:
   - test_store_credential_success: Valid request returns 201 with CredentialResponse
   - test_store_credential_duplicate: Duplicate (account_id, type) returns 409
   - test_store_credential_unauthorized: Wrong account_id returns 403
   - test_store_credential_missing_fields: Missing required fields returns 422

3. **Test cases for GET /api/credentials**:
   - test_list_credentials_success: Returns list of credential metadata
   - test_list_credentials_no_plaintext: Response does NOT contain api_key or secret_key values
   - test_list_credentials_unauthorized: Wrong account returns 403

4. **Test cases for POST /api/credentials/{id}/validate**:
   - test_validate_credential_success: Mock Alpaca API, returns is_valid=True
   - test_validate_credential_invalid: Mock failed auth, returns is_valid=False
   - test_validate_credential_inactive: Inactive credential returns 400
   - test_validate_credential_unauthorized: Wrong user returns 403

5. **Test cases for PUT /api/credentials/{id}**:
   - test_update_credential_success: Update api_key works
   - test_update_credential_deactivate: Setting is_active=False works
   - test_update_credential_unauthorized: Wrong user returns 403

6. **Test cases for DELETE /api/credentials/{id}**:
   - test_delete_credential_success: Returns 204
   - test_delete_credential_unauthorized: Wrong user returns 403

Use monkeypatch to:
- Override get_current_user dependency with mock user
- Set ENCRYPTION_KEY environment variable
- Mock httpx calls to Alpaca API for validate tests

Follow existing test patterns from test_user_credentials.py.
  </action>
  <verify>
```bash
cd apps/orchestrator_3_stream/backend && uv run pytest tests/test_credential_endpoints.py -v --collect-only 2>/dev/null | head -50 || echo "Test collection check"

# At minimum verify the file exists and can be parsed
uv run python -c "
import sys
sys.path.insert(0, '.')
import tests.test_credential_endpoints as t
print(f'Test module loaded: {t.__name__}')
print('OK - Test file created')
"
```
  </verify>
  <done>test_credential_endpoints.py with tests for all credential endpoints</done>
</task>

<task type="auto">
  <name>Task 3: Create credential lifecycle tests</name>
  <files>apps/orchestrator_3_stream/backend/tests/test_credential_lifecycle.py</files>
  <action>
Create test file for decrypt-on-demand pattern:

1. **Test encrypt-decrypt roundtrip**:
   - test_credential_roundtrip: Store credential, retrieve, verify decryption matches original

2. **Test decrypt-on-demand context manager**:
   - test_decrypt_context_manager_yields_plaintext: Context manager yields correct plaintext
   - test_decrypt_context_manager_unauthorized: Wrong user_id raises ValueError
   - test_decrypt_context_manager_inactive: Inactive credential raises ValueError
   - test_decrypt_context_manager_not_found: Invalid credential_id raises ValueError

3. **Test no credential caching**:
   - test_no_credential_caching: Verify same credential decrypted twice produces identical results (proves no caching issues)
   - test_credential_not_in_session: After context exit, plaintext should be garbage collected (verify variable scope)

4. **Test Alpaca validation function**:
   - test_validate_alpaca_credentials_success: Mock successful Alpaca response
   - test_validate_alpaca_credentials_invalid: Mock 401 response
   - test_validate_alpaca_credentials_network_error: Mock network failure

5. **Test end-to-end lifecycle**:
   - test_store_validate_delete_lifecycle: Full CRUD cycle
   - test_credential_update_lifecycle: Store, update, verify new values decrypt correctly

Use monkeypatch for:
- ENCRYPTION_KEY environment variable
- Mock database connections where needed
- Mock httpx for Alpaca API calls

Follow existing test patterns from test_user_credentials.py and test_encryption_service.py.
  </action>
  <verify>
```bash
cd apps/orchestrator_3_stream/backend && uv run pytest tests/test_credential_lifecycle.py -v --collect-only 2>/dev/null | head -50 || echo "Test collection check"

# At minimum verify the file exists and can be parsed
uv run python -c "
import sys
sys.path.insert(0, '.')
import tests.test_credential_lifecycle as t
print(f'Test module loaded: {t.__name__}')
print('OK - Test file created')
"
```
  </verify>
  <done>test_credential_lifecycle.py with tests for decrypt-on-demand pattern and Alpaca validation</done>
</task>

<task type="auto">
  <name>Task 4: Create real Alpaca integration tests (NO MOCKS)</name>
  <files>apps/orchestrator_3_stream/backend/tests/test_real_alpaca_integration.py</files>
  <action>
Create integration test file that uses REAL Alpaca paper credentials from .env:

**CRITICAL: These tests use real Alpaca API - NO MOCKING**

## Pre-requisite: Add unique env vars to root .env

Before running tests, add these UNIQUE env var names to root .env (avoiding duplicate key issue):
```bash
# Add to .env - UNIQUE names for Paper Account 1 (seagerjoe@gmail.com)
ALPACA_PAPER1_API_KEY=PK3VNBKEIVBKWNOA3O2QBHTYED
ALPACA_PAPER1_SECRET_KEY=AfwcUtD1TAB62JPdYxq5ZuyyKvjXRkzjnCt7D23H3iUA
ALPACA_PAPER_ENDPOINT=https://paper-api.alpaca.markets
```

## Test Configuration

```python
import os
import pytest
import httpx
from dotenv import load_dotenv

# Load root .env
load_dotenv(dotenv_path="/Users/muzz/Desktop/tac/TOD/.env")

# Use UNIQUE env var names to avoid duplicate key issue
REAL_ALPACA_API_KEY = os.getenv("ALPACA_PAPER1_API_KEY")
REAL_ALPACA_SECRET_KEY = os.getenv("ALPACA_PAPER1_SECRET_KEY")
ALPACA_PAPER_ENDPOINT = os.getenv("ALPACA_PAPER_ENDPOINT", "https://paper-api.alpaca.markets")
TEST_USER_EMAIL = "seagerjoe@gmail.com"

# API timeout for real calls (seconds)
ALPACA_API_TIMEOUT = 10.0
```

## Test 1: Real Alpaca validation with account status check
**test_validate_real_alpaca_credentials**:
- Store real Alpaca paper credentials for seagerjoe@gmail.com user
- Call POST /api/credentials/{id}/validate
- Assert is_valid=True (REAL API call to Alpaca)
- **Assert account_status == "ACTIVE"** (verify account is fully operational)
- Assert Alpaca returns account info (id, account_number present)
- Clean up: delete the stored credential after test

## Test 2: Invalid credentials error handling
**test_validate_invalid_alpaca_credentials**:
- Store INTENTIONALLY INVALID credentials (e.g., "INVALID_KEY", "INVALID_SECRET")
- Call POST /api/credentials/{id}/validate
- Assert is_valid=False
- Assert error_message contains "unauthorized" or "invalid"
- Clean up: delete the stored credential after test

## Test 3: End-to-end credential flow with real data
**test_e2e_store_validate_use_delete**:
- Store real credentials → returns credential_id
- Validate credentials → returns is_valid=True with account_status="ACTIVE"
- Use invoke_with_stored_credential to call Alpaca get_account()
- Verify real account data returned: check for `id`, `cash`, `buying_power` fields
- Delete credentials
- Verify credential no longer accessible (GET returns 404)

## Test 4: RLS isolation blocks cross-user access
**test_rls_blocks_other_user_credentials**:
- Setup: Store credential for seagerjoe@gmail.com
- Create temporary test user in database (different user_id)
- Switch auth context to new user
- Attempt to GET /api/credentials → should return empty list (not seagerjoe's)
- Attempt to GET /api/credentials/{seagerjoe_cred_id} → should return 403
- Attempt to validate seagerjoe's credential → should return 403
- Cleanup: delete temp user, delete seagerjoe's test credential

## Test 5: Network timeout handling
**test_alpaca_validation_timeout_handling**:
- Mock httpx to simulate timeout (use respx or similar)
- Call POST /api/credentials/{id}/validate
- Assert appropriate error response (not a crash)
- Assert error indicates network/timeout issue

## Test Fixtures

```python
@pytest.fixture
def real_alpaca_creds():
    """Load real Alpaca paper credentials from UNIQUE env vars."""
    api_key = os.getenv("ALPACA_PAPER1_API_KEY")
    secret_key = os.getenv("ALPACA_PAPER1_SECRET_KEY")
    if not api_key or not secret_key:
        pytest.skip("ALPACA_PAPER1_API_KEY/ALPACA_PAPER1_SECRET_KEY not set in .env")
    return {
        "api_key": api_key,
        "secret_key": secret_key,
        "environment": "paper",
        "endpoint": ALPACA_PAPER_ENDPOINT
    }

@pytest.fixture
def invalid_alpaca_creds():
    """Return intentionally invalid credentials for error testing."""
    return {
        "api_key": "INVALID_TEST_KEY_12345",
        "secret_key": "INVALID_TEST_SECRET_67890",
        "environment": "paper",
        "endpoint": ALPACA_PAPER_ENDPOINT
    }
```

## Test Helpers

- get_or_create_test_user(email): Lookup user by email in Neon DB, or create if not exists
- cleanup_test_credential(credential_id, user_id): Delete credential with proper RLS context
- create_temp_test_user(): Create ephemeral user for isolation test, return user_id

## Database & API Notes

- Use real Neon database (DATABASE_URL from .env)
- Use real Alpaca paper API (ALPACA_PAPER_ENDPOINT)
- Tests must be ephemeral: clean up all created data
- User seagerjoe@gmail.com already exists in DB (Better Auth)
- All API calls use ALPACA_API_TIMEOUT (10 seconds)

## Skip Conditions

- Skip if ALPACA_PAPER1_API_KEY not in env
- Skip if ALPACA_PAPER1_SECRET_KEY not in env
- Skip if DATABASE_URL not in env
- Mark with @pytest.mark.integration

## Example Enhanced Test

```python
@pytest.mark.integration
@pytest.mark.timeout(30)  # Overall test timeout
async def test_validate_real_alpaca_credentials(real_alpaca_creds, test_client, db_session):
    """Test credential validation with REAL Alpaca paper API."""
    # Store credential
    response = test_client.post("/api/credentials/store", json={
        "account_id": TEST_USER_ACCOUNT_ID,
        "credential_type": "alpaca_paper",
        "api_key": real_alpaca_creds["api_key"],
        "secret_key": real_alpaca_creds["secret_key"],
        "environment": "paper"
    })
    assert response.status_code == 201
    cred_id = response.json()["id"]

    try:
        # Validate with REAL Alpaca API
        validate_resp = test_client.post(
            f"/api/credentials/{cred_id}/validate",
            timeout=ALPACA_API_TIMEOUT
        )
        assert validate_resp.status_code == 200

        result = validate_resp.json()
        # Core validation
        assert result["is_valid"] == True
        # Account status check (not just valid creds, but ACTIVE account)
        assert result.get("account_status") == "ACTIVE", \
            f"Expected ACTIVE account, got: {result.get('account_status')}"
        # Verify we got real account data
        assert "account_id" in result or "id" in result

    finally:
        # Cleanup - always delete test credential
        test_client.delete(f"/api/credentials/{cred_id}")

@pytest.mark.integration
async def test_validate_invalid_alpaca_credentials(invalid_alpaca_creds, test_client, db_session):
    """Test that invalid credentials return is_valid=False (not crash)."""
    # Store intentionally invalid credential
    response = test_client.post("/api/credentials/store", json={
        "account_id": TEST_USER_ACCOUNT_ID,
        "credential_type": "alpaca_paper",
        "api_key": invalid_alpaca_creds["api_key"],
        "secret_key": invalid_alpaca_creds["secret_key"],
        "environment": "paper"
    })
    assert response.status_code == 201
    cred_id = response.json()["id"]

    try:
        # Validate with REAL Alpaca API (should fail gracefully)
        validate_resp = test_client.post(
            f"/api/credentials/{cred_id}/validate",
            timeout=ALPACA_API_TIMEOUT
        )
        assert validate_resp.status_code == 200  # Endpoint works

        result = validate_resp.json()
        assert result["is_valid"] == False  # But credentials invalid
        assert "error" in result or "message" in result

    finally:
        # Cleanup
        test_client.delete(f"/api/credentials/{cred_id}")
```
  </action>
  <verify>
```bash
cd apps/orchestrator_3_stream/backend && uv run pytest tests/test_real_alpaca_integration.py -v -m integration --collect-only 2>/dev/null | head -40 || echo "Collected integration tests"

# Verify file exists and has required test functions
uv run python -c "
import sys
sys.path.insert(0, '.')
import tests.test_real_alpaca_integration as t

# Check for required test functions
required_tests = [
    'test_validate_real_alpaca_credentials',
    'test_validate_invalid_alpaca_credentials',
    'test_e2e_store_validate_use_delete',
    'test_rls_blocks_other_user_credentials'
]
for test_name in required_tests:
    assert hasattr(t, test_name), f'Missing test: {test_name}'

print(f'Test module: {t.__name__}')
print(f'Required tests present: {len(required_tests)}')
print('OK - Real integration test file created with all required tests')
"
```
  </verify>
  <done>test_real_alpaca_integration.py with real Alpaca API tests, invalid credential handling, account status verification, and RLS isolation verification</done>
</task>

</tasks>

<verification>
1. alpaca_agent_service.py has invoke_with_stored_credential method
2. test_credential_endpoints.py exists with endpoint tests
3. test_credential_lifecycle.py exists with lifecycle tests
4. test_real_alpaca_integration.py exists with REAL Alpaca tests (5 test functions)
5. All test files can be imported without errors
6. `uv run pytest tests/test_credential_*.py --collect-only` shows all test cases
7. `uv run pytest tests/test_real_alpaca_integration.py -m integration` passes with real Alpaca API
8. Root .env has unique env vars: ALPACA_PAPER1_API_KEY, ALPACA_PAPER1_SECRET_KEY
</verification>

<success_criteria>
Phase 3 Success Criteria verification:
1. API endpoint accepts Alpaca API key + secret and stores encrypted - verified by test_store_credential_success
2. Credentials are decrypted only during Alpaca API calls - verified by decrypt-on-demand context manager pattern
3. Decrypted credentials are never held in session state or cache - verified by context manager scope tests
4. Credential update endpoint allows changing existing account credentials - verified by test_update_credential_success
5. Real Alpaca API validation works end-to-end - verified by test_validate_real_alpaca_credentials (NO MOCKS)
6. **Account status verified as "ACTIVE"** - not just valid creds, but fully operational account
7. **Invalid credential handling works** - verified by test_validate_invalid_alpaca_credentials (graceful error)
8. RLS isolation works - verified by test_rls_blocks_other_user_credentials (seagerjoe's creds invisible to other users)

REAL CREDENTIAL TEST STRATEGY:
- Test 1 (Positive): Use seagerjoe@gmail.com with real Alpaca paper credentials (ALPACA_PAPER1_* env vars)
- Test 2 (Negative): Use intentionally invalid credentials, verify graceful error handling
- Test 3 (Isolation): Create temporary test user in DB, verify RLS blocks access to seagerjoe's credentials
- All tests are ephemeral: clean up created data after each test
- All API calls use 10-second timeout to prevent hangs

⚠️  PRE-REQUISITE: Add unique env vars to root .env before running tests:
```
ALPACA_PAPER1_API_KEY=PK3VNBKEIVBKWNOA3O2QBHTYED
ALPACA_PAPER1_SECRET_KEY=AfwcUtD1TAB62JPdYxq5ZuyyKvjXRkzjnCt7D23H3iUA
ALPACA_PAPER_ENDPOINT=https://paper-api.alpaca.markets
```
</success_criteria>

<output>
After completion, create `.planning/phases/03-credential-management/03-03-SUMMARY.md`
</output>
