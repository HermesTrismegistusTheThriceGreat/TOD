---
phase: 03-credential-management
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/orchestrator_3_stream/backend/schemas/credential_schemas.py
  - apps/orchestrator_3_stream/backend/modules/credential_service.py
autonomous: true

must_haves:
  truths:
    - "Pydantic schemas with SecretStr mask credential values in logs and errors"
    - "Credential service provides async context manager for decrypt-on-demand pattern"
    - "Response schemas never include plaintext api_key or secret_key fields"
  artifacts:
    - path: "apps/orchestrator_3_stream/backend/schemas/credential_schemas.py"
      provides: "Pydantic request/response models for credential API"
      exports: ["StoreCredentialRequest", "UpdateCredentialRequest", "CredentialResponse", "ValidateCredentialResponse"]
    - path: "apps/orchestrator_3_stream/backend/modules/credential_service.py"
      provides: "Credential storage/retrieval logic with decrypt-on-demand"
      exports: ["get_decrypted_alpaca_credential", "validate_alpaca_credentials"]
  key_links:
    - from: "credential_schemas.py"
      to: "pydantic.SecretStr"
      via: "api_key and secret_key fields use SecretStr type"
      pattern: "api_key:\\s*SecretStr"
    - from: "credential_service.py"
      to: "user_models.py"
      via: "imports UserCredentialORM for database queries"
      pattern: "from modules.user_models import"
---

<objective>
Create Pydantic schemas and credential service for secure credential management.

Purpose: Establish the data layer for credential API endpoints with SecretStr masking and decrypt-on-demand pattern.
Output: credential_schemas.py with request/response models, credential_service.py with storage/retrieval logic.
</objective>

<execution_context>
@/Users/muzz/.claude/get-shit-done/workflows/execute-plan.md
@/Users/muzz/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-credential-management/03-RESEARCH.md
@apps/orchestrator_3_stream/backend/modules/user_models.py
@apps/orchestrator_3_stream/backend/modules/encryption_service.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Pydantic credential schemas</name>
  <files>apps/orchestrator_3_stream/backend/schemas/credential_schemas.py</files>
  <action>
Create new directory `schemas/` if not exists. Create credential_schemas.py with:

1. **StoreCredentialRequest** - Request to store new credential:
   - account_id: str (UUID of user_accounts.id)
   - credential_type: str ("alpaca", "polygon")
   - api_key: SecretStr (masked in logs)
   - secret_key: SecretStr (masked in logs)

2. **UpdateCredentialRequest** - Request to update existing credential:
   - api_key: Optional[SecretStr]
   - secret_key: Optional[SecretStr]
   - is_active: Optional[bool]

3. **CredentialResponse** - Response with metadata only (NEVER plaintext credentials):
   - id: str
   - account_id: str
   - credential_type: str
   - is_active: bool
   - created_at: str
   - updated_at: str
   - Config: from_attributes = True

4. **ValidateCredentialRequest** - Request to validate credentials:
   - api_key: SecretStr
   - secret_key: SecretStr

5. **ValidateCredentialResponse** - Validation result:
   - is_valid: bool
   - message: str
   - account_type: Optional[str] ("paper" or "live")

6. **ListCredentialsResponse** - Response for listing credentials:
   - status: str
   - credentials: List[CredentialResponse]
   - count: int

All SecretStr fields must be imported from pydantic. Use Field() for descriptions.
  </action>
  <verify>
```bash
cd apps/orchestrator_3_stream/backend && uv run python -c "
from schemas.credential_schemas import (
    StoreCredentialRequest, UpdateCredentialRequest, CredentialResponse,
    ValidateCredentialRequest, ValidateCredentialResponse, ListCredentialsResponse
)
from pydantic import SecretStr

# Verify SecretStr masking works
req = StoreCredentialRequest(
    account_id='test-uuid',
    credential_type='alpaca',
    api_key=SecretStr('PKABC123'),
    secret_key=SecretStr('sp_secret')
)
# Verify SecretStr masks values
assert 'PKABC123' not in str(req), 'SecretStr should mask api_key'
assert 'sp_secret' not in str(req), 'SecretStr should mask secret_key'
# Verify get_secret_value() retrieves plaintext
assert req.api_key.get_secret_value() == 'PKABC123'
print('OK - Schemas validated')
"
```
  </verify>
  <done>All schema classes import without error, SecretStr masks credential values in string representation</done>
</task>

<task type="auto">
  <name>Task 2: Create credential service with decrypt-on-demand</name>
  <files>apps/orchestrator_3_stream/backend/modules/credential_service.py</files>
  <action>
Create credential_service.py with:

1. **get_decrypted_alpaca_credential** async context manager:
   - Parameters: conn (asyncpg connection), credential_id (str/UUID), user_id (str)
   - Queries UserCredentialORM by id
   - Validates credential belongs to user_id (raise ValueError if not)
   - Validates credential is_active (raise ValueError if not)
   - Yields tuple (api_key, secret_key) as plaintext
   - Uses try/finally to ensure plaintext is discarded on exit
   - TypeDecorator handles decryption automatically when accessing .api_key and .secret_key

2. **validate_alpaca_credentials** async function:
   - Parameters: api_key (str), secret_key (str)
   - Uses httpx to call Alpaca API GET /v2/account with authentication
   - Returns tuple (is_valid: bool, account_type: Optional[str])
   - On success: returns (True, "paper" or "live" based on response)
   - On auth failure: returns (False, None)
   - Uses ALPACA_BASE_URL from config (paper or live URL)
   - NEVER logs the actual credential values

3. **store_credential** async function:
   - Parameters: conn, account_id (UUID), user_id (str), credential_type (str), api_key (str), secret_key (str)
   - Creates UserCredentialORM instance (TypeDecorator encrypts automatically)
   - Inserts into database
   - Returns credential id

Import from modules.user_models: UserCredentialORM, UserAccountORM
Import from modules.config: ALPACA_BASE_URL (or default to paper API URL)
Use httpx for async HTTP calls to Alpaca validation endpoint.
  </action>
  <verify>
```bash
cd apps/orchestrator_3_stream/backend && uv run python -c "
from modules.credential_service import (
    get_decrypted_alpaca_credential,
    validate_alpaca_credentials,
    store_credential
)
import inspect

# Verify get_decrypted_alpaca_credential is async context manager
assert inspect.isasyncgenfunction(get_decrypted_alpaca_credential.__wrapped__) or hasattr(get_decrypted_alpaca_credential, '__aenter__'), 'Should be async context manager'

# Verify validate_alpaca_credentials is async function
assert inspect.iscoroutinefunction(validate_alpaca_credentials), 'Should be async function'

# Verify store_credential is async function
assert inspect.iscoroutinefunction(store_credential), 'Should be async function'

print('OK - Credential service functions validated')
"
```
  </verify>
  <done>credential_service.py exports get_decrypted_alpaca_credential context manager and validate_alpaca_credentials function</done>
</task>

</tasks>

<verification>
1. `schemas/` directory exists with credential_schemas.py
2. All Pydantic schema classes can be imported
3. SecretStr fields mask values in string representation
4. credential_service.py exports required functions
5. No credential values appear in any log statements
</verification>

<success_criteria>
- StoreCredentialRequest.api_key is SecretStr type
- CredentialResponse does NOT have api_key or secret_key fields
- get_decrypted_alpaca_credential is async context manager
- validate_alpaca_credentials returns (bool, Optional[str]) tuple
</success_criteria>

<output>
After completion, create `.planning/phases/03-credential-management/03-01-SUMMARY.md`
</output>
