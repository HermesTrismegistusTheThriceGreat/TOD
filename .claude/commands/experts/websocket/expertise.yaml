# WebSocket Implementation Expertise
# Multi-Agent Orchestration System - Real-Time Communication Architecture

overview:
  description: "FastAPI WebSocket-based event bus for real-time communication between backend services and frontend clients"
  primary_endpoint: "/ws"
  default_url: "ws://127.0.0.1:9403/ws"
  architecture_pattern: "Centralized WebSocketManager with one-to-many broadcast"
  integration_depth: "Deep integration with Claude SDK hooks for real-time agent execution events"

core_implementation:
  websocket_manager:
    file: "apps/orchestrator_3_stream/backend/modules/websocket_manager.py"
    lines: 392
    purpose: "Centralized connection manager and event broadcaster"

    state_management:
      active_connections:
        type: "List[WebSocket]"
        description: "All active WebSocket connections"
      connection_metadata:
        type: "Dict[WebSocket, dict]"
        description: "Metadata per connection (client_id, connected_at)"

    lifecycle_methods:
      connect:
        lines: "25-53"
        flow:
          - "Accept WebSocket handshake"
          - "Add to active_connections list"
          - "Create metadata with client_id and connected_at timestamp"
          - "Send connection_established message with client ID"

      disconnect:
        lines: "55-69"
        flow:
          - "Remove from active_connections list"
          - "Delete metadata entry"
          - "Log disconnection with connection count"

      send_to_client:
        lines: "71-80"
        behavior: "Send JSON to single client, auto-disconnect on failure"

      broadcast:
        lines: "82-119"
        behavior: "Send JSON to all connected clients (with optional exclude)"
        concurrency: "Safe for concurrent calls"

    broadcast_methods:
      agent_management:
        - "broadcast_agent_created (line 125)"
        - "broadcast_agent_updated (line 129)"
        - "broadcast_agent_deleted (line 135)"
        - "broadcast_agent_status_change (line 139)"
        - "broadcast_agent_log (line 152)"
        - "broadcast_agent_summary_update (line 156)"
      orchestrator:
        - "broadcast_orchestrator_updated (line 162)"
        - "broadcast_orchestrator_chat (line 176)"
      chat:
        - "broadcast_chat_message (line 172)"
        - "broadcast_chat_stream (line 190)"
        - "set_typing_indicator (line 211)"
      system:
        - "broadcast_system_log (line 168)"
        - "broadcast_error (line 180)"
      adw:
        - "broadcast_adw_created (line 232)"
        - "broadcast_adw_updated (line 236)"
        - "broadcast_adw_event (line 242)"
        - "broadcast_adw_step_change (line 248)"
        - "broadcast_adw_event_summary_update (line 263)"
      alpaca:
        - "broadcast_option_price_update (line 280)"
        - "broadcast_spot_price_update (line 299)"
        - "broadcast_option_price_batch (line 315)"
        - "broadcast_position_update (line 332)"
        - "broadcast_alpaca_status (line 345)"

  fastapi_endpoint:
    file: "apps/orchestrator_3_stream/backend/main.py"
    lines: "896-1000"
    route: "@app.websocket('/ws')"

    handler_flow:
      - "await ws_manager.connect(websocket)"
      - "Enter infinite receive loop"
      - "Parse incoming JSON by 'type' field"
      - "Handle ADW and agent broadcast requests"
      - "Catch WebSocketDisconnect and cleanup"

    incoming_message_types:
      - "adw_broadcast (routes to adw_created, adw_updated, adw_event, adw_step_change, adw_status, adw_event_summary_update)"
      - "agent_broadcast (routes to agent_created, agent_status_changed, agent_updated)"

event_types:
  connection:
    - name: "connection_established"
      source: "websocket_manager.py"
      fields:
        type: "connection_established"
        client_id: "UUID string"
        timestamp: "ISO8601"
        message: "Connected to Orchestrator Backend"

  chat:
    - name: "chat_stream"
      source: "websocket_manager.py:190"
      fields:
        type: "chat_stream"
        orchestrator_agent_id: "string"
        chunk: "string"
        is_complete: "boolean"
        timestamp: "ISO8601"

    - name: "chat_typing"
      source: "websocket_manager.py:211"
      fields:
        type: "chat_typing"
        orchestrator_agent_id: "string"
        is_typing: "boolean"
        timestamp: "ISO8601"

    - name: "orchestrator_chat"
      source: "websocket_manager.py:176"
      fields:
        type: "orchestrator_chat"
        chat: "object"
        message: "object (id, orchestrator_agent_id, sender_type, receiver_type, message, agent_id, metadata, timestamp)"

  agent_management:
    - name: "agent_created"
      fields: { type: "agent_created", agent: "object", timestamp: "ISO8601" }

    - name: "agent_updated"
      fields: { type: "agent_updated", agent_id: "string", agent: "object", timestamp: "ISO8601" }

    - name: "agent_deleted"
      fields: { type: "agent_deleted", agent_id: "string", timestamp: "ISO8601" }

    - name: "agent_status_changed"
      fields: { type: "agent_status_changed", agent_id: "string", old_status: "string", new_status: "string", timestamp: "ISO8601" }

  agent_activity:
    - name: "agent_log"
      source: "command_agent_hooks.py"
      purpose: "Real-time agent execution logs from hooks"
      fields: { type: "agent_log", log: "object", timestamp: "ISO8601" }
      hook_sources: ["PreToolUse", "PostToolUse", "UserPromptSubmit", "Stop", "Compact", "PostToolFile"]

    - name: "agent_summary_update"
      source: "command_agent_hooks.py"
      fields: { type: "agent_summary_update", agent_id: "string", summary: "string", timestamp: "ISO8601" }

  analysis_blocks:
    - name: "thinking_block"
      source: "orchestrator_service.py"
      fields: { type: "thinking_block", data: "object (id, orchestrator_agent_id, thinking, timestamp)" }
      persistence: "Saved to system_logs table"

    - name: "tool_use_block"
      source: "orchestrator_service.py"
      fields: { type: "tool_use_block", data: "object (id, orchestrator_agent_id, tool_name, tool_input, tool_use_id, timestamp)" }
      persistence: "Saved to system_logs table"

  orchestrator:
    - name: "orchestrator_updated"
      fields: { type: "orchestrator_updated", orchestrator: "object (id, input_tokens, output_tokens, total_cost, updated_at)", timestamp: "ISO8601" }

  system:
    - name: "system_log"
      fields: { type: "system_log", log: "object", data: "object (alternative)", timestamp: "ISO8601" }

    - name: "error"
      fields: { type: "error", message: "string", details: "object (optional)", timestamp: "ISO8601" }

    - name: "heartbeat"
      source: "websocket_manager.py:375"
      status: "Method exists but not scheduled"
      fields: { type: "heartbeat", timestamp: "ISO8601", active_connections: "int" }

  autocomplete:
    - name: "autocomplete_started"
      fields: { type: "autocomplete_started", orchestrator_agent_id: "string", timestamp: "ISO8601" }

    - name: "autocomplete_completed"
      fields: { type: "autocomplete_completed", orchestrator_agent_id: "string", suggestions: "array", timestamp: "ISO8601" }

  adw:
    - name: "adw_created"
      source: "websocket_manager.py:232"
      fields: { type: "adw_created", adw: "object", timestamp: "ISO8601" }

    - name: "adw_updated"
      source: "websocket_manager.py:236"
      fields: { type: "adw_updated", adw_id: "string", adw: "object", timestamp: "ISO8601" }

    - name: "adw_event"
      source: "websocket_manager.py:242"
      fields: { type: "adw_event", adw_id: "string", event: "object", timestamp: "ISO8601" }

    - name: "adw_step_change"
      source: "websocket_manager.py:248"
      fields: { type: "adw_step_change", adw_id: "string", step: "string", event_type: "string", payload: "object", timestamp: "ISO8601" }

    - name: "adw_event_summary_update"
      source: "websocket_manager.py:263"
      fields: { type: "adw_event_summary_update", adw_id: "string", event_id: "string", summary: "string", timestamp: "ISO8601" }

  alpaca:
    - name: "option_price_update"
      source: "websocket_manager.py:280"
      purpose: "Real-time option price from Alpaca stream"
      fields: { type: "option_price_update", update: "object (symbol, bid_price, ask_price, mid_price, timestamp)", timestamp: "ISO8601" }

    - name: "spot_price_update"
      source: "websocket_manager.py:299"
      purpose: "Real-time spot (underlying) price"
      fields: { type: "spot_price_update", update: "object (symbol, bid_price, ask_price, mid_price, timestamp)", timestamp: "ISO8601" }

    - name: "option_price_batch"
      source: "websocket_manager.py:315"
      purpose: "Batch price updates for efficiency"
      fields: { type: "option_price_batch", updates: "array", count: "int", timestamp: "ISO8601" }

    - name: "position_update"
      source: "websocket_manager.py:332"
      fields: { type: "position_update", position: "object", timestamp: "ISO8601" }

    - name: "alpaca_status"
      source: "websocket_manager.py:345"
      fields: { type: "alpaca_status", status: "string (connected|disconnected|error)", details: "object", timestamp: "ISO8601" }

streaming_architecture:
  message_processing_flow:
    description: "Three-phase logging pattern for orchestrator messages"

    phase_1_pre_execution:
      file: "orchestrator_service.py"
      steps:
        - "Insert user message to orchestrator_chat table"
        - "Broadcast user message event via WebSocket"
        - "Spawn async AI summarization task (background)"

    phase_2_execution:
      file: "orchestrator_service.py"
      process_user_message_line: 474
      steps:
        - "Iterate through Claude SDK AsyncIterable[Message] blocks"
        - "For TextBlock: Save to DB → Broadcast → Spawn summarization"
        - "For ThinkingBlock: Save to system_logs → Broadcast as thinking_block"
        - "For ToolUseBlock: Save to system_logs → Broadcast as tool_use_block"
        - "Set typing indicator at start, clear at end"

    phase_3_post_execution:
      steps:
        - "Update session ID in database"
        - "Extract cost/tokens from ResultMessage"
        - "Update orchestrator costs in database"
        - "Broadcast orchestrator_updated event"

  claude_sdk_integration:
    orchestrator_hooks:
      file: "backend/modules/orchestrator_hooks.py"
      lines: 168
      hook_types:
        PreToolUse:
          tools_monitored: ["create_agent", "command_agent", "list_agents", "delete_agent"]
          flow: "Log → Broadcast → Database"
        PostToolUse: { status: "Minimal implementation" }
        Stop: { flow: "Log → Broadcast → Database" }

    command_agent_hooks:
      file: "backend/modules/command_agent_hooks.py"
      lines: 629
      hook_types:
        PreToolUse: { captures: "Tool name, parameters, timestamp" }
        PostToolUse: { captures: "Tool name, result, duration" }
        UserPromptSubmit: { captures: "Prompt text, timestamp" }
        Stop: { captures: "Final state, session duration" }
        Compact: { captures: "Compaction trigger, size before/after" }
        PostToolFile: { captures: "File path, change type, diff" }

    hook_execution_flow:
      - "Hook fires during Claude SDK execution"
      - "Insert event to agent_logs table with event_category='hook'"
      - "Immediately broadcast via ws_manager.broadcast_agent_log()"
      - "Spawn async summarization in background (non-blocking)"
      - "Frontend receives event in real-time"

concurrency_patterns:
  async_execution:
    http_endpoint: "/send_chat"
    pattern: "Fire and forget with asyncio.create_task()"
    flow:
      - "HTTP /send_chat returns immediately"
      - "Message processing in background via asyncio.create_task()"
      - "All WebSocket broadcasts happen during processing"

  execution_locking:
    mechanism: "_execution_lock: AsyncIO Lock"
    purpose: "Prevent concurrent orchestrator execution"

  background_tasks:
    summarization:
      trigger: "After each agent log or chat message"
      method: "asyncio.create_task()"
      model: "Claude Haiku (cost efficiency)"
      blocking: false

database_persistence:
  pattern: "Write-through: Database first, then broadcast"
  tables:
    orchestrator_chat: { broadcast_timing: "After INSERT" }
    agent_logs: { broadcast_timing: "After INSERT" }
    system_logs: { broadcast_timing: "After INSERT" }

frontend_integration:
  connection_service:
    file: "frontend/src/services/chatService.ts"
    lines: 378

    reconnect_config:
      maxAttempts: 5
      baseDelayMs: 1000
      maxDelayMs: 30000
      pattern: "Exponential backoff"

    exported_types:
      - "OptionPriceUpdateMessage"
      - "OptionPriceBatchMessage"
      - "PositionUpdateMessage"
      - "AlpacaStatusMessage"
      - "SpotPriceUpdateMessage"
      - "WebSocketCallbacks"

    callbacks:
      onMessageReceived: "Called for EVERY WebSocket message before routing"
      onConnected: "Called on successful connection"
      onChatStream: "Receives streaming chat chunks"
      onTyping: "Typing indicator updates"
      onThinkingBlock: "Receives thinking block data"
      onToolUseBlock: "Receives tool usage data"
      onAgentLog: "Receives agent activity logs"
      onAgentCreated: "New agent created"
      onAgentUpdated: "Agent updated"
      onAgentDeleted: "Agent deleted"
      onAgentStatusChange: "Agent status changed"
      onAgentSummaryUpdate: "Agent summary updated"
      onOrchestratorUpdated: "Orchestrator state updated"
      onAutocompleteStarted: "Autocomplete generation started"
      onAutocompleteCompleted: "Autocomplete suggestions received"
      onAdwCreated: "ADW created"
      onAdwUpdated: "ADW updated"
      onAdwEvent: "ADW event received"
      onAdwStepChange: "ADW step changed"
      onAdwEventSummaryUpdate: "ADW event summary updated"
      onOptionPriceUpdate: "Option price update"
      onOptionPriceBatch: "Batch option price updates"
      onPositionUpdate: "Position update"
      onAlpacaStatus: "Alpaca connection status"
      onSpotPriceUpdate: "Spot price update"
      onError: "Handles errors"
      onDisconnected: "Handles disconnection"

    message_routing:
      pattern: "Switch statement on message.type"
      counter_pattern: "onMessageReceived callback fires BEFORE JSON parsing"

  state_management:
    store: "orchestratorStore.ts (Pinia)"
    file: "frontend/src/stores/orchestratorStore.ts"
    lines: 1913
    pattern: "Unidirectional data flow"

    session_state:
      websocketEventCount:
        type: "ref<number>"
        line: 99
        reset_on: "connect, disconnect"

    raf_batchers:
      purpose: "Batch high-frequency price updates per animation frame"
      optionPriceBatcher: "Batches option price updates"
      spotPriceBatcher: "Batches spot price updates"

    websocket_actions:
      incrementWebSocketEventCount: { line: 989 }
      connectWebSocket: { lines: "993-1100", counter_behavior: "Resets websocketEventCount on connection" }

  composables:
    useHeaderBar:
      file: "frontend/src/composables/useHeaderBar.ts"
      lines: 226
      websocket_counter:
        line: 106
        implementation: "computed(() => store.websocketEventCount)"

monitoring:
  session_event_counter:
    purpose: "Track total WebSocket messages received during current session"
    implementation:
      callback: "onMessageReceived in WebSocketCallbacks interface"
      trigger_point: "chatService.ts (before JSON parsing)"
      state: "orchestratorStore.websocketEventCount (ref<number>)"
      increment: "orchestratorStore.incrementWebSocketEventCount()"
      reset: "On connect and disconnect"
    characteristics:
      - "Counts ALL messages regardless of type"
      - "Session-scoped (not persisted)"
      - "Resets to 0 on new connection"

configuration:
  environment_variables:
    BACKEND_HOST: { default: "127.0.0.1" }
    BACKEND_PORT: { default: "9403" }
    WEBSOCKET_URL: { default: "ws://127.0.0.1:9403/ws" }
  config_file: "backend/modules/config.py"

testing:
  manual_testing_utility:
    file: "backend/tests/test_websocket_raw.py"
    purpose: "Manual WebSocket testing and message inspection"

known_issues:
  no_heartbeat_scheduling:
    severity: "Medium"
    description: "send_heartbeat() method exists but isn't scheduled"
    solution: "Schedule heartbeat in app lifespan event"

  no_authentication:
    severity: "Medium (Security)"
    description: "/ws endpoint has no auth check"
    solution: "Add session token validation on connection"

potential_enhancements:
  - "Implement heartbeat scheduling"
  - "Add WebSocket authentication"
  - "Connection rate limiting"
  - "Selective event subscriptions"

key_file_locations:
  core:
    websocket_manager: "apps/orchestrator_3_stream/backend/modules/websocket_manager.py (392 lines)"
    main_endpoint: "apps/orchestrator_3_stream/backend/main.py (line 896)"
  hooks:
    orchestrator_hooks: "apps/orchestrator_3_stream/backend/modules/orchestrator_hooks.py (168 lines)"
    command_agent_hooks: "apps/orchestrator_3_stream/backend/modules/command_agent_hooks.py (629 lines)"
  services:
    orchestrator_service: "apps/orchestrator_3_stream/backend/modules/orchestrator_service.py (1048 lines, process_user_message: 474)"
  frontend:
    chat_service: "apps/orchestrator_3_stream/frontend/src/services/chatService.ts (378 lines)"
    orchestrator_store: "apps/orchestrator_3_stream/frontend/src/stores/orchestratorStore.ts (1913 lines)"
    header_composable: "apps/orchestrator_3_stream/frontend/src/composables/useHeaderBar.ts (226 lines)"

architecture_summary: |
  The WebSocket implementation serves as a centralized event bus enabling real-time
  communication in the multi-agent orchestration system. A single WebSocketManager
  coordinates all connections and broadcasts events from multiple sources including
  orchestrator execution, agent activity, Claude SDK hooks, ADW workflows, and
  Alpaca price streams.

  The architecture follows a write-through pattern where events are persisted to
  PostgreSQL before broadcast. Deep integration with Claude SDK hooks captures
  execution events in real-time.

  Frontend uses RAF batching for high-frequency price updates to prevent UI freezing.
  Automatic reconnection with exponential backoff ensures connection reliability.
